# SynergyFinder
# Functions for plot synergy scores
#
# Functions in this page:
#
# PlotSynergy: Plot drug interaction landscape
# .ExtendedScores: Internal function facilating drug interaction landscape 
#                  ploting 

#' Drug interaction landscape
#'
#' A function to visualize the synergy scores for drug combinations as 2D or 3D
#' interaction landscape over the dose-response matrix.
#'
#' @param data a list object generated by function 
#'     \code{\link{CalculateSynergy}}.
#' @param type a parameter to specify the type of the interaction landscape, 2D, 
#'     3D or both. By default, 2D interaction landscape is returned.
#' @param save.file a logical parameter to specify if the interaction landscape
#'     is saved as a pdf file in the current working directory or returned as an
#'     R object. By default, it is FALSE.
#' @param len a parameter to specify how many values need to be predicted 
#'    between two concentrations
#' @param pair.index a parameter to specify which drug combination if there are 
#'    many drug combinations in the data. By default, it is NULL so that the 
#'    synergy score visualization of all the drug combinations in the data is 
#'    returned.
#' @param legend.start a parameter to specify the starting point of the legend. 
#'    By defualt, it is NULL so the legend starting point is fixed by the data 
#'    automatically.
#' @param legend.end a parameter to specify the ending point of the legend. By 
#'    defualt, it is NULL so the legend ending point is fixed by the data 
#'    automatically.
#' @param col.range a parameter to specify the starting and ending concentration 
#'    of the drug on x-axis. Use e.g., c(1, 3) to specify that only from 1st to 
#'    3rd concentrations of the drug on x-axis are used. By default, it is NULl 
#'    so all the concentrations are used.
#' @param row.range a parameter to specify the starting and ending concentration 
#'    of the drug on y-axis. Use e.g., c(1, 3) to specify that only from 1st to 
#'    3rd concentrations of the drug on y-axis are used. By default, it is NULl 
#'    so all the concentrations are used.
#' @return a pdf file or the interaction landscapes which are only displayed 
#'    It depends on the \code{save.file} parameter.
#'    
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#'
#' @export
#' 
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' scores <- CalculateSynergy(data)
#' PlotSynergy(scores, "2D")
#' PlotSynergy(scores, "3D")
PlotSynergy <- function(data, type = "2D", save.file = FALSE, len = 3, 
                        pair.index = NULL, legend.start = NULL, 
                        legend.end = NULL, row.range = NULL, col.range = NULL){
  # 1. Check input data
  if (!is.list(data)) {
      stop("Input data is not a list format!")
  }
  if (!("scores" %in% names(data))) {
    stop("There should be a list named 'scores'.")
  }
  
  # 2. Extract scores matrices
  scores <- data$scores
  drug.pairs <- data$drug.pairs  
  
  if(!is.null(pair.index)) {
    blocks <- pair.index
  } else {
    blocks <- names(scores)
  }
  
  plots <- vector(mode="list", length=length(blocks))
  names(plots) <- blocks
  for (block in blocks) {
    scores.dose <- scores[[block]]
    drug.col <- drug.pairs$drug_col[drug.pairs$block_id == block]
    drug.row <- drug.pairs$drug_row[drug.pairs$block_id == block]
    
    scores.tmp <- scores.dose

    if (!is.null(col.range)) {
      scores.tmp <- scores.tmp[,col.range[1]:col.range[2]]
    }

    if (!is.null(row.range)) {
        scores.tmp <- scores.tmp[row.range[1]:row.range[2], ]
    }
    row.conc <- as.numeric(rownames(scores.tmp)) # concentrations on the row
    col.conc <- as.numeric(colnames(scores.tmp)) # concentrations on the column
    summary.score <- round(mean(scores.tmp[row.conc != 0, col.conc != 0],
                                na.rm = TRUE), 3)
    # drug.col: the col-wise drug
    # drug.row: the row-wise drug
    
    # kriging with kriging from SpatialExtremes package!
    

    
    nr <- nrow(scores.tmp)
    nc <- ncol(scores.tmp)
    
    # coordinates for the predicted values of the matrix
    
    # len: how many values need to be predicted between two concentrations
    scores.extended <- .ExtendedScores(scores.tmp, len)
    
    # get the subset of the extended matrix with predicted values
    mat.tmp <- scores.extended
    # pred.cory <- as.numeric(colnames(mat.tmp))
    # pred.corx <- as.numeric(rownames(mat.tmp))
    # if(!is.null(col.range)){
    #   # selecting cols
    #   mat.tmp <- mat.tmp[, which(pred.cory >= col.conc[col.range[1]] & 
    #                                pred.cory <= col.conc[col.range[2]])]
    # }
    # if(!is.null(row.range)){
    #   # selecting rows
    #   mat.tmp <- mat.tmp[which(pred.corx >= row.conc[row.range[1]] & 
    #                              pred.corx <= row.conc[row.range[2]]), ]
    # }
    
    # the matrix for plotting
    pp <- data.frame(x = rep(colnames(mat.tmp), each = nrow(mat.tmp)),
                     y = rep(rownames(mat.tmp), ncol(mat.tmp)),
                     z = c(mat.tmp))
    
    plot.title <- paste("Average synergy: ", summary.score, 
                        " (",data$method,")", sep = "")

    conc.runit <- drug.pairs$conc_r_unit[drug.pairs$block_id == block]
    conc.cunit <- drug.pairs$conc_c_unit[drug.pairs$block_id == block]
    unit.rtext <- paste("(", conc.runit, ")", sep = "")
    unit.ctext <- paste("(", conc.cunit, ")", sep = "")
    file.name <- paste(drug.row, drug.col, "synergy", block, 
                       data$method, "pdf", sep = ".")
    drug.row <- paste(drug.row, unit.rtext, sep = " ")
    drug.col <- paste(drug.col, unit.ctext, sep = " ")
    max.dose <- max(abs(scores.dose))
    color.range <- round(max.dose + 5, -1)
    if(is.null(legend.start)){
        start.point <- -color.range
    } else {
        start.point <- legend.start
    }
    
    if(is.null(legend.end)) {
        end.point <- color.range
    } else {
        end.point <- legend.end
    }
    
    # colors
    levels <- seq(start.point, end.point, by = 2)
    col1 <- grDevices::colorRampPalette(c('green', 
                                        "#FFFFFF"))(length(which(levels <= 0)))
    col2 <- grDevices::colorRampPalette(c("#FFFFFF", 
                                          'red'))(length(which(levels >= 0)))
    col <- c(col1, col2[-1])
    

    if (type == "3D") {
      # x-axis ticks settings
      if(!is.null(col.range)) {
        xaxis <- list(at = seq(1, ncol(mat.tmp), by = len + 1),
                      labels = round(col.conc[col.range[1]:col.range[2]], 3))
      } else {
        xaxis <- list(at = seq(1, ncol(mat.tmp), by = len + 1),
                      labels = round(col.conc, 3))
      }
      
      # y-axis ticks settings
      if(!is.null(row.range)) {
        yaxis <- list(at = seq(1, nrow(mat.tmp), by = len + 1),
                   labels = round(row.conc[row.range[1]:row.range[2]], 3))
      } else {
        yaxis <- list(at = seq(1, nrow(mat.tmp), by = len + 1),
                   labels = round(row.conc, 3))
      }
      
      
      par1 <- list(arrows = FALSE, distance = c(0.8,0.8,0.8), col = 1,
                   cex = 0.8, z = list(tick.number = 6),
                   x=xaxis, y = yaxis)
      zlabs <- list(expression("Synergy score"), rot = 90, 
                    cex = 1, axis.key.padding = 0)
      xpar <- list(as.character(drug.col), cex = 1, rot = 20)
      ypar <- list(as.character(drug.row), cex = 1, rot = -50)
      
      fig <- lattice::wireframe(t(mat.tmp),scales = par1, drape = TRUE,
                          colorkey = list(space = "top",width = 0.5),
                          screen = list(z = 30, x = -55),
                          zlab = zlabs, xlab = xpar, ylab = ypar,
                          zlim = c(start.point, end.point),
                          col.regions = col,
                          main = plot.title,
                          at = lattice::do.breaks(c(start.point, end.point), 
                                         length(col)),
                          par.settings=list(axis.line=list(col="transparent")),
                          zoom = 1, aspect = 1)
      print(fig)
      fig <- grDevices::recordPlot()
    } else if (type == "2D") {
      grDevices::dev.new(noRStudioGD = TRUE)
      graphics::layout(matrix(c(1, 2), nrow = 2L, ncol = 1L), 
                       heights = c(0.1, 1))
      graphics::par(mar = c(0, 6.1, 2.1, 4.1))
      suppressWarnings(graphics::par(mgp = c(3, -1.5, 0)))
      #levels <- seq(start.point, end.point, by = 2)
      #col <- colorpanel(end.point, low = "green", mid = "white", high = "red")
      graphics::plot.new()
      graphics::plot.window(ylim = c(0, 1), xlim = range(levels), 
                            xaxs = "i", yaxs = "i")
      graphics::rect(levels[-length(levels)], 0, levels[-1L], 0.3, 
                     col = col, border = NA)
      graphics::axis(3,tick = FALSE, at = lattice::do.breaks(c(start.point, 
                                                               end.point), 
                                      round((end.point - start.point)/10, 2)))
      graphics::title(plot.title)
      graphics::par(mar = c(5.1,4.1,1.1,2.1))
      suppressWarnings(graphics::par(mgp = c(2,1,0)))
      graphics::plot.new()
      mat.tmp <- t(mat.tmp)
      x.2D <- (seq_len(dim(mat.tmp)[1]) - 1) / (dim(mat.tmp)[1] - 1)
      y.2D <- (seq_len(dim(mat.tmp)[2]) - 1) / (dim(mat.tmp)[2] - 1)
      graphics::plot.window(asp = NA, xlim = range(x.2D), ylim = range(y.2D), 
                            "", xaxs = "i", yaxs = "i")
      graphics::.filled.contour(x.2D, y.2D, z = mat.tmp, levels, col = col)
      ## grid(dim(c)[1] - 1, dim(c)[2] - 1, col = "gray", lty = "solid", 
      ## lwd = 0.3)
      graphics::box()
      graphics::mtext(drug.col, 1, cex = 1, padj = 3)
      graphics::mtext(drug.row, 2, cex = 1, las = 3, padj = -3)
      if(!is.null(row.range)) {
        yconc <- round(row.conc[row.range[1]:row.range[2]], 3)
      } else {
        yconc <- round(row.conc, 3)
      }
      
      if(!is.null(col.range)) {
        xconc <- round(col.conc[col.range[1]:col.range[2]], 3)
      } else {
        xconc <- round(col.conc, 3)
      }

      graphics::axis(side = 1, at = seq(0, 1, by = 1/(length(xconc) - 1)), 
                     labels = xconc)
      graphics::axis(side = 2, at = seq(0, 1, by = 1/(length(yconc) - 1)), 
                     labels = yconc)
      fig <- grDevices::recordPlot()
      grDevices::dev.off()
    } else {
      # 3d plot
      # x-axis ticks settings
      if(!is.null(col.range)) {
        xaxis <- list(at = seq(1, ncol(mat.tmp), by = len + 1),
                      labels = round(col.conc[col.range[1]:col.range[2]], 3))
      } else {
        xaxis <- list(at = seq(1, ncol(mat.tmp), by = len + 1),
                      labels = round(col.conc, 3))
      }
      
      # y-axis ticks settings
      if(!is.null(row.range)) {
        yaxis <- list(at = seq(1, nrow(mat.tmp), by = len + 1),
                      labels = round(row.conc[row.range[1]:row.range[2]], 3))
      } else {
        yaxis <- list(at = seq(1, nrow(mat.tmp), by = len + 1),
                      labels = round(row.conc, 3))
      }
      
      
      par1 <- list(arrows=FALSE, distance=c(0.8,0.8,0.8), col = 1,
                   cex = 0.8, z = list(tick.number = 6),
                   x=xaxis, y = yaxis)
      zlabs <- list(expression("Synergy score"), rot = 90, 
                    cex = 1, axis.key.padding = 0)
      xpar <- list(as.character(drug.col), cex = 1, rot = 20)
      ypar <- list(as.character(drug.row), cex = 1, rot = -50)
      
      syn.3d.plot <- lattice::wireframe(t(mat.tmp),scales = par1,
                       drape = TRUE, colorkey = list(space = "top",width = 0.5),
                       screen = list(z = 30, x = -55),
                       zlab = zlabs, xlab = xpar, ylab = ypar,
                       zlim = c(start.point, end.point),
                       col.regions = col,
                       main = plot.title,
                       at = lattice::do.breaks(c(start.point, end.point), 
                                               length(col)),
                       par.settings = list(axis.line=list(col="transparent")),
                       zoom = 1, aspect = 1)
      # 2d plot
      graphics::layout(matrix(c(1, 2, 3, 3), nrow = 2L, ncol = 2L),
                       heights = c(0.1, 1))
      graphics::par(mar = c(0, 6.1, 2.1, 4.1))
      suppressWarnings(graphics::par(mgp = c(3, -0.8, 0)))
      graphics::plot.new()
      graphics::plot.window(ylim = c(0, 1), xlim = range(levels),
                            xaxs = "i", yaxs = "i")
      graphics::rect(levels[-length(levels)],0, levels[-1L],0.3,
                     col = col, border = NA)
      graphics::axis(3, tick = FALSE,
                     at = lattice::do.breaks(c(start.point, end.point),
                                             end.point/10))
      graphics::title(plot.title)
      graphics::par(mar = c(5.1,4.1,1.1,2.1))
      suppressWarnings(graphics::par(mgp = c(2,1,0)))
      graphics::plot.new()
      mat.tmp <- t(mat.tmp)
      x.2D <- (seq_len(dim(mat.tmp)[1]) - 1) / (dim(mat.tmp)[1] - 1)
      y.2D <- (seq_len(dim(mat.tmp)[2]) - 1) / (dim(mat.tmp)[2] - 1)
      graphics::plot.window(asp = NA, xlim = range(x.2D), ylim = range(y.2D),
                            "", xaxs = "i", yaxs = "i")
      graphics::.filled.contour(x.2D, y.2D, z = mat.tmp, levels, col = col)
      graphics::box()
      graphics::mtext(drug.col, 1, cex = 1, padj = 3)
      graphics::mtext(drug.row, 2, cex = 1, las = 3, padj = -3)
      if(!is.null(row.range)) {
        yconc <- round(row.conc[row.range[1]:row.range[2]], 3)
      } else {
        yconc <- round(row.conc, 3)
      }
      
      if(!is.null(col.range)) {
        xconc <- round(col.conc[col.range[1]:col.range[2]], 3)
      } else {
        xconc <- round(col.conc, 3)
      }
      
      graphics::axis(side = 1, at = seq(0, 1, by = 1/(length(xconc) - 1)),
                     labels = xconc)
      graphics::axis(side = 2, at = seq(0, 1, by = 1/(length(yconc) - 1)),
                     labels = yconc)
      print(syn.3d.plot, position = c(0.5,0, 1, 1), newpage = FALSE)
      fig <- grDevices::recordPlot()
    }
    plots[[block]] <- fig
    if(save.file) {
      if (type %in% c("2D", "3D")) {
        grDevices::pdf(file.name, width = 10, height = 10)
      } else {
        grDevices::pdf(file.name, width = 12, height = 6)
      }
      print(fig)
      grDevices::dev.off()
    }

  }

  if(!save.file) {
    for(block in blocks) {
      grDevices::dev.new(noRStudioGD = TRUE)
      grDevices::replayPlot(plots[[block]])
    }
  }
}

.ExtendedScores <-  function (scores.mat, len) {
  # len: how many values need to be predicted between two adjacent elements
  #      of scores.dose
  options(scipen = 999)
  nr <- nrow(scores.mat)
  nc <- ncol(scores.mat)
  
  # missing value imputation
  while (sum(is.na(scores.mat))) {
    scores.mat <- ImputeNA(scores.mat)
  }
  ext.row.len <- (nr - 1) * (len + 2) - (nr - 2)
  ext.col.len <- (nc - 1) * (len + 2) - (nc - 2)
  
  extended.row.idx <- seq(1, nr, length = ext.row.len)
  extended.col.idx <- seq(1, nc, length = ext.col.len)
  
  krig.coord <- cbind(rep(extended.row.idx, each = ext.col.len),
                      rep(extended.col.idx, times = ext.row.len))
  extended.scores <- SpatialExtremes::kriging(data = c(scores.mat),
                                  data.coord = cbind(rep(seq_len(nr), nc),
                                                    rep(seq_len(nc), each=nr)),
                                  krig.coord = krig.coord,
                                  cov.mod = "whitmat", grid = FALSE,
                                  sill = 1, range = 10,
                                  smooth = 0.8)$krig.est
  extended.scores <- matrix(extended.scores, nrow = ext.row.len,
                            ncol = ext.col.len, byrow = TRUE)
  
  # extended.scores = data.frame(extended.scores)
  extended.scores <- round(extended.scores, 3)
  
  row.dose <- as.numeric(rownames(scores.mat))
  col.dose <- as.numeric(colnames(scores.mat))
  
  extend.row.dose <- mapply(function(x, y){seq(from = x, to = y,
                                               length.out = len + 2)},
                            row.dose[-nr], row.dose[-1])
  extend.row.dose <- unique(round(c(extend.row.dose), 8))
  
  extend.col.dose <- mapply(function(x, y){seq(from = x, to = y,
                                               length.out = len + 2)},
                            col.dose[-nc], col.dose[-1])
  extend.col.dose <- unique(round(c(extend.col.dose), 8))
  
  rownames(extended.scores) <- extend.row.dose
  colnames(extended.scores) <- extend.col.dose
  
  return(extended.scores)
}
