# SynergyFinder
# Functions for plotting response or synergy scores for 2 drug combination.
#
# Functions in this page:
# Plot2DrugHeatmap: Heatmap Plot for 2-drug Combination Dose-Response/Synergy
#                   Scores
# Plot2DrugSurface: 3D surface Plot for 2-drug Combination Dose-Response/Synergy
#                   Scores
# Auxiliary functions:
# .Extract2DrugPlotData: Extract Data for 2 Drug combination plots
# .RoundValues: Round the Numbers for Plotting
# .Pt2mm: Round the Numbers for Plotting
# .ExtendedScores: Convert Font Size from pt to mm

#' Heatmap Plot for 2-drug Combination Dose-Response/Synergy Scores
#' 
#' This function will generate a plot for 2-drug combinations. The axes are the
#' dosage at which drugs are tested. The values could be observed response,
#' synergy scores or the reference effects calculated from different models.
#'
#' @param data A list object generated by function \code{\link{ReshapeData}}.
#' @param plot_block A character/integer. It indicates the block ID for the
#'   block to visualize.
#' @param drugs A vector of characters or integers with length of 2. It contains
#'   the index for two drugs to plot. For example, \code{c(1, 2)} indicates to
#'   plot "drug1" and "drug2" in the input \code{data}.
#' @param plot_value A character value. It indicates the value to be visualized.
#'   If the \code{data} is the direct output from \link{ReshapeData}, the values
#'   for this parameter are:
#'   \itemze{
#'     \item \strong{response_origin} The original response value in input data.
#'     It might be % inhibition or % viability.
#'     \item \strong{response} The % inhibition after preprocess by function 
#'     \link{ReshapeData}
#'   }
#'   If the \code{data} is the output from \link{CalculateSynergy}, following
#'   values are also available:
#'   \itemze{
#'     \item \strong{ZIP_ref, Bliss_ref, HSA_ref, Loewe_ref} The reference
#'     additive effects predicted by ZIP, Bliss, HSA or Loewe model,
#'     respectively.
#'     \item \strong{ZIP_synergy, Bliss_synergy, HSA_synergy, Loewe_synergy}
#'     The synergy score calculated by ZIP, Bliss, HSA or Loewe model,
#'     respectively.
#'     \item \strong{ZIP_fit} The response fitted by ZIP model.
#'   }
#' @param statistic A character or NULL. It indicates the statistics printed
#'   in the plot while there are replicates in input data. Available values are:
#'   \itemize{
#'     \item \strong{sem} Standard error of mean;
#'     \item \strong{ci} 95% confidence interval.
#'   }
#'   If it is \code{NULL}, no statistics will be printed.
#' @param summary_statistic A vector of characters or NULL. It indicates the
#'   summary statistics for all the \code{plot_value} in whole combination
#'   matrix. Available values are:
#'   \itemize{
#'     \item \strong{mean} Median value for all the responses or synergy
#'     scores in the matrix;
#'     \item \strong{median} Median value for all the responses or synergy
#'     scores in the matrix;
#'     \item \strong{quantile_90} 90% quantile. User could change the number to
#'     print different sample quantile. For example quantile_50 equal to median. 
#'   }
#'   If it is \code{NULL}, no statistics will be printed.
#' @param high_value_color An R color value. It indicates the color for the
#'   high values.
#' @param low_value_color An R color value. It indicates the color for low
#'   values.
#'
#' @return A ggplot plot object.
#'
#' @export
#'
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' Plot2DHeatmap(data)
Plot2DrugHeatmap <- function(data,
                             plot_type = "heatmap",
                             plot_block = 1,
                             drugs = c(1, 2),
                             plot_value = "response",
                             statistic = NULL,
                             summary_statistic = NULL,
                             high_value_color = "#A90217",
                             low_value_color = "#2166AC") {
  # Extract plot data
  plot_data <- .Extract2DrugPlotData(
    data = data,
    plot_block = plot_block,
    drugs = drugs,
    plot_value = plot_value,
    statistic = statistic
  )
  plot_table <- plot_data$plot_table
  drug_pair <- plot_data$drug_pair
  
  # Generate plot title and legend title
  if (plot_value == "response") {
    plot_title <- paste(
      "Dose Response Matrix",
      sep = " "
    )
    legend_title <- "Inhibition (%)"
  } else if (plot_value == "response_origin") {
    plot_title <- paste(
      "Dose Response Matrix",
      sep = " "
    )
    legend_title <- paste(stringr::str_to_title(drug_pair$input_type), "%")
  } else {
    plot_title <- switch(
      sub(".*_", "", plot_value),
      "ref" = sub("_ref", " Reference Additive Effect", plot_value),
      "fit" = sub("_fit", " Fitted Effect", plot_value),
      "synergy" = sub("_synergy", " Synergy Score", plot_value)
    )
    legend_title <- switch(
      sub(".*_", "", plot_value),
      "ref" = "Inhibition (%)",
      "fit" = "Inhibition (%)",
      "synergy" = "Synergy Score"
    )
  }
  # plot subtitle (summary statistics)
  plot_subtitle <- c()
  if (!is.null(summary_statistic)) {
    avail_value <- grepl("mean|median|quantile_\\d+", summary_statistic)
    if ("mean" %in% summary_statistic) {
      value <- .RoundValues(mean(plot_table$value))
      plot_subtitle <- c(plot_subtitle, paste0("Mean: ", value))
    }
    if ("median" %in% summary_statistic) {
      value <- .RoundValues(median(plot_table$value))
      plot_subtitle <-  c(plot_subtitle, paste0("Median: ", value))
    }
    qua <- grep("quantile_\\d+", summary_statistic, value = TRUE)
    if (length(qua) > 0) {
      for (q in qua) {
        pro <- as.numeric(sub("quantile_", "", q))
        value <- .RoundValues(quantile(plot_table$value, probs = pro / 100))
        plot_subtitle <-  c(plot_subtitle, paste0(pro, "% Quantile: ", value))
      }
    }
  }
  plot_subtitle <- paste(plot_subtitle, collapse = " | ")
  
  # plot heatmap for dose-response matrix
  p <- ggplot2::ggplot(
    data = plot_table,
    aes(x = conc2, y = conc1, fill = value)
  ) +
    ggplot2::geom_tile() +
    ggplot2::geom_text(ggplot2::aes(label = text), size = .Pt2mm(7)) +
    ggplot2::scale_fill_gradient2(
      high= high_value_color,
      mid = "#FFFFFF",
      low = low_value_color,
      midpoint = 0,
      name = legend_title
    ) +
    ggplot2::xlab(paste0(drug_pair$drug2, " (", drug_pair$conc_unit2, ")")) +
    ggplot2::ylab(paste0(drug_pair$drug1, " (", drug_pair$conc_unit1, ")")) +
    # Add the title for heatmap
    ggplot2::ggtitle(
      label = paste0(
        "Block ",
        plot_block,
        ": ",
        plot_title
      ),
      subtitle = plot_subtitle
    ) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(
        size = 13.5,
        face = "bold",
        hjust = 0.5
      ),
      plot.subtitle = ggplot2::element_text(
        size = 12,
        hjust = 0.5
      ),
      panel.background = ggplot2::element_blank(),
      # Set label's style of heatmap
      axis.text = ggplot2::element_text(
        size = 10
      ),
      axis.title = ggplot2::element_text(
        face = "italic",
        size = 10
      )
    )
  
  return(p)
}


#' 3D Surface Plot for 2-drug Combination Dose-Response/Synergy Scores
#' 
#' This function will generate a surface plot for 2-drug combinations. The axes
#' are the dosage for each drug. The values could be observed response,
#' synergy scores or the reference effects calculated from different models.
#'
#' @param data A list object generated by function \code{\link{ReshapeData}}.
#' @param plot_block A character/integer. It indicates the block ID for the
#'   block to visualize.
#' @param drugs A vector of characters or integers with length of 2. It contains
#'   the index for two drugs to plot. For example, \code{c(1, 2)} indicates to
#'   plot "drug1" and "drug2" in the input \code{data}.
#' @param plot_value A character value. It indicates the score or response value
#'   to be visualized. If the \code{data} is the direct output from
#'   \link{ReshapeData}, the available values for this parameter are:
#'   \itemze{
#'     \item \strong{response_origin} The original response value in input data.
#'     It might be % inhibition or % viability.
#'     \item \strong{response} The % inhibition after preprocess by function 
#'     \link{ReshapeData}
#'   }
#'   If the \code{data} is the output from \link{CalculateSynergy}, following
#'   values are also available:
#'   \itemze{
#'     \item \strong{ZIP_ref, Bliss_ref, HSA_ref, Loewe_ref} The reference
#'     additive effects predicted by ZIP, Bliss, HSA or Loewe model,
#'     respectively.
#'     \item \strong{ZIP_synergy, Bliss_synergy, HSA_synergy, Loewe_synergy}
#'     The synergy score calculated by ZIP, Bliss, HSA or Loewe model,
#'     respectively.
#'     \item \strong{ZIP_fit} The response fitted by ZIP model.
#'   }
#' @param summary_statistic A vector of characters or NULL. It indicates the
#'   summary statistics for all the \code{plot_value} in whole combination
#'   matrix. Available values are:
#'   \itemize{
#'     \item \strong{mean} Median value for all the responses or synergy
#'     scores in the matrix;
#'     \item \strong{median} Median value for all the responses or synergy
#'     scores in the matrix;
#'     \item \strong{quantile_90} 90% quantile. User could change the number to
#'     print different sample quantile. For example quantile_50 equal to median. 
#'   }
#'   If it is \code{NULL}, no statistics will be printed.
#' @param high_value_color An R color value. It indicates the color for the
#'   high values.
#' @param low_value_color An R color value. It indicates the color for low
#'   values.
#'
#' @return A project recorded by \link[recordPlot]{grDevice}.
#'
#' @export
#'
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' Plot2DrugSurface(data)
Plot2DrugSurface <- function(data,
                             plot_block = 1,
                             drugs = c(1, 2),
                             plot_value = "response",
                             summary_statistic = NULL,
                             dynamic = FALSE,
                             high_value_color = "#A90217",
                             low_value_color = "#2166AC") {
  # Extract plot data
  plot_data <- .Extract2DrugPlotData(
    data = data,
    plot_block = plot_block,
    drugs = drugs,
    plot_value = plot_value,
    statistic = NULL
  )
  plot_table <- plot_data$plot_table
  drug_pair <- plot_data$drug_pair
  
  # Generate plot title and legend title
  if (plot_value == "response") {
    plot_title <- paste(
      "Dose Response Matrix",
      sep = " "
    )
    legend_title <- "Inhibition (%)"
    z_axis_title <- "Response (% inhibition)"
  } else if (plot_value == "response_origin") {
    plot_title <- paste(
      "Dose Response Matrix",
      sep = " "
    )
    legend_title <- paste0(stringr::str_to_title(drug_pair$input_type), " (%)")
    z_axis_title <- paste0("Response (% ",drug_pair$input_type,")")
  } else {
    plot_title <- switch(
      sub(".*_", "", plot_value),
      "ref" = sub("_ref", " Reference Additive Effect", plot_value),
      "fit" = sub("_fit", " Fitted Effect", plot_value),
      "synergy" = sub("_synergy", " Synergy Score", plot_value)
    )
    legend_title <- switch(
      sub(".*_", "", plot_value),
      "ref" = "Inhibition (%)",
      "fit" = "Inhibition (%)",
      "synergy" = "Synergy Score"
    )
    z_axis_title <- switch(
      sub(".*_", "", plot_value),
      "ref" = "Response (% inhibition)",
      "fit" = "Response (% inhibition)",
      "synergy" = "Synergy Score"
    )
  }
  # plot subtitle (summary statistics)
  plot_subtitle <- c()
  if (!is.null(summary_statistic)) {
    avail_value <- grepl("mean|median|quantile_\\d+", summary_statistic)
    if ("mean" %in% summary_statistic) {
      value <- .RoundValues(mean(plot_table$value))
      plot_subtitle <- c(plot_subtitle, paste0("Mean: ", value))
    }
    if ("median" %in% summary_statistic) {
      value <- .RoundValues(median(plot_table$value))
      plot_subtitle <-  c(plot_subtitle, paste0("Median: ", value))
    }
    qua <- grep("quantile_\\d+", summary_statistic, value = TRUE)
    if (length(qua) > 0) {
      for (q in qua) {
        pro <- as.numeric(sub("quantile_", "", q))
        value <- .RoundValues(quantile(plot_table$value, probs = pro / 100))
        plot_subtitle <-  c(plot_subtitle, paste0(pro, "% Quantile: ", value))
      }
    }
  }
  plot_subtitle <- paste(plot_subtitle, collapse = " | ")
  
  conc1 <- unique(plot_table$conc1)
  conc2 <- unique(plot_table$conc2)
  
  # kriging with kriging from SpatialExtremes package!
  mat <- reshape2::acast(plot_table, conc1~conc2, value.var = "value")
  # len: how many values need to be predicted between two concentrations
  len <- 3
  extended_mat <- .ExtendedScores(mat, len)
  colnames(extended_mat) <- seq(1, nrow(extended_mat))
  rownames(extended_mat) <- seq(1, ncol(extended_mat))
  x_ticks <- seq(1, nrow(extended_mat), by = len + 1)
  y_ticks <- seq(1, ncol(extended_mat), by = len + 1)
  x_ticks_text <- as.character(sort(conc1))
  y_ticks_text <- as.character(sort(conc2))
  x_axis_title <- paste0(drug_pair$drug1, " (", drug_pair$conc_unit1, ")")
  y_axis_title <- paste0(drug_pair$drug2, " (", drug_pair$conc_unit2, ")")
  
  if (dynamic) {
    x <-  seq(1, ncol(extended_mat))
    y <- seq(1, nrow(extended_mat))
    # Color palette
    color_range <- max(abs(extended_mat)) + 5
    start_point <- -color_range
    end_point <- color_range
    # Hover text
    concs <- expand.grid(conc1, conc2)
    hover_text <- NULL
    for (i in 1:nrow(concs)) {
      hover_text <- c(
        hover_text,
        paste0(
          drug_pair[, c("drug1", "drug2")],
          ": ",
          sapply(concs[i, ], as.character),
          " ",
          drug_pair[, c("conc_unit1", "conc_unit1")],
          "<br>",
          collapse = ""
        )
      )
    }
    hover_text <- paste0(
      hover_text,
      "Value: ",
      .RoundValues(plot_table$value),
      sep = ""
    )
    hover_text <- matrix(hover_text, nrow = length(conc1))
    hover_text_mat <- matrix(rep(NA, length(extended_mat)),
                             nrow = nrow(extended_mat))
    for (i in 1:length(x_ticks)) {
      for (j in 1:length(y_ticks)) {
        hover_text_mat[x_ticks[i], y_ticks[j]] <- hover_text[i, j]
      }
    }


    p <- plotly::plot_ly() %>% 
      plotly::add_surface(
        name = "surface",
        x = ~x,
        y = ~y,
        z = t(extended_mat),
        text = t(hover_text_mat),
        hoverinfo = "text",
        colorscale = list(
          c(0, low_value_color),
          c(0.5, "white"),
          c(1, high_value_color)
        ),
        cauto = FALSE,
        colorbar = list(
          x = 1,
          y = 0.75,
          align = "center",
          outlinecolor = "#FFFFFF",
          tickcolor = "#FFFFFF",
          title = legend_title
        ),
        cmin = start_point,
        cmax = end_point,
        contours = list(
          x = list(
            # highlight = FALSE,
            show = TRUE,
            color = 'black',
            width = 1,
            start = 1,
            end = max(x),
            size = 1
          ),
          y = list(
            # highlight = FALSE,
            show = TRUE,
            color = 'black',
            width = 1,
            start = 1,
            end = max(y),
            size = 1
          )#,
          # z = list(highlight = FALSE)
        )
      ) %>% 
      plotly::layout(
        title = list(
          text = paste0("<b>", plot_title, "</b>"),
          tickfont = list(size = 18, family = "arial"),
          y = 0.99
        ),
        scene = list(
          aspectratio = list(x=1, y=1, z=1),
          xaxis = list(
            title = paste0("<i>", x_axis_title, "</i>"),
            tickfont = list(size = 12, family = "arial"),
            ticks = "none",
            showspikes = FALSE,
            tickmode = "array", 
            tickvals = x_ticks,
            ticktext = x_ticks_text
          ),
          yaxis = list(
            title = paste0("<i>", y_axis_title, "</i>"),
            tickfont = list(size = 12, family = "arial"),
            ticks = "none",
            showspikes = FALSE,
            tickmode = "array", 
            tickvals = y_ticks,
            ticktext = y_ticks_text
          ),
          zaxis = list(
            title = paste0("<i>", z_axis_title, "</i>"),
            tickfont = list(size = 12, family = "arial"),
            ticks = "none",
            tickmode = "array",
            showspikes = FALSE
          ),
          camera = list(eye = list(x = -1.25, y = -1.25, z = 1.25))
        )
      )
  } else { # static plot
    # Color palette
    color_range <- round(max(abs(plot_table$value)) + 5, 2)
    start_point <- -color_range
    end_point <- color_range
    color_level <- round(seq(start_point, end_point, by = 2), 0)
    col1 <- grDevices::colorRampPalette(c(
      "#FFFFFF",
      low_value_color
    ))(length(which(color_level <= 0)))
    col2 <- grDevices::colorRampPalette(c(
      "#FFFFFF",
      high_value_color
    ))(length(which(color_level >= 0)))
    col <- c(rev(col1), col2[-1])
    scale_par <- list(
      arrows = FALSE,
      distance = c(0.8, 0.8, 0.8),
      col = 1,
      z = list(
        tick.number = 6,
        cex = 0.75),
      x =  list(
        at = x_ticks,
        labels = x_ticks_text,
        cex = 0.75
      ),
      y = list(
        at = y_ticks,
        labels = y_ticks_text,
        cex = 0.75
      )
    )
  
    # Let the text able to shown outside the plot panel
    clip <- lattice::trellis.par.get("clip")
    clip$panel <- "off"
    lattice::trellis.par.set("clip", clip)
    p <- lattice::wireframe(
      extended_mat,
      scales = scale_par,
      drape = TRUE,
      colorkey = list(
        space = "right",
        width = 2,
        height = 0.4,
        cex = 0.75
      ),
      screen = list(z = 30, x = -55),
      zlab = list(
        z_axis_title,
        axis.key.padding = 0,
        cex = 0.75,
        rot = 93
      ),
      xlab = list(
        x_axis_title,
        cex = 0.75,
        rot = 23
      ),
      ylab = list(
        y_axis_title,
        cex = 0.75,
        rot = -53
      ),
      zlim = c(min(plot_table$value) - 5, max(plot_table$value) + 5),
      col.regions = col,
      main = list(
        label = plot_title,
        fontsize = 13.5
      ),
      at = lattice::do.breaks(
        c(start_point, end_point),
        length(col)
      ),
      par.settings = list(
        axis.line = list(col = "transparent")
      ),
      zoom = 1,
      aspect = 1,
      panel = function(...) {
        lattice::panel.wireframe(...)
        # subtitle
        grid::grid.text(
          label = plot_subtitle,
          x=unit(0.55, "npc"),
          y=unit(1, "npc"),
          gp = gpar(col = "black", fontsize = 10.5) # pt
        )
        # legend title
        grid::grid.text(
          label = legend_title,
          x = unit(1.05, "npc"),
          y = unit(0.75, "npc"),
          gp = gpar(col = "black", fontsize = 8.5) # pt
        )
        },
      pretty = TRUE
    )
    print(p)
    p <- grDevices::recordPlot()
  }
  return(p)
}

# Auxiliary functions -----------------------------------------------------

#' Extract Data for 2 Drug Combination Plots
#'
#' @param data A list object generated by function \code{\link{ReshapeData}}.
#' @param plot_block A character/integer. It indicates the block ID for the
#'   block to visualize.
#' @param drugs A vector of characters or integers with length of 2. It contains
#'   the index for two drugs to plot. For example, \code{c(1, 2)} indicates to
#'   plot "drug1" and "drug2" in the input \code{data}.
#' @param plot_value A character value. It indicates the value to be visualized.
#'   If the \code{data} is the direct output from \link{ReshapeData}, the values
#'   for this parameter are:
#'   \itemze{
#'     \item \strong{response_origin} The original response value in input data.
#'     It might be % inhibition or % viability.
#'     \item \strong{response} The % inhibition after preprocess by function 
#'     \link{ReshapeData}
#'   }
#'   If the \code{data} is the output from \link{CalculateSynergy}, following
#'   values are also available:
#'   \itemze{
#'     \item \strong{ZIP_ref, Bliss_ref, HSA_ref, Loewe_ref} The reference
#'     additive effects predicted by ZIP, Bliss, HSA or Loewe model,
#'     respectively.
#'     \item \strong{ZIP_synergy, Bliss_synergy, HSA_synergy, Loewe_synergy}
#'     The synergy score calculated by ZIP, Bliss, HSA or Loewe model,
#'     respectively.
#'     \item \strong{ZIP_fit} The response fitted by ZIP model.
#'   }
#' @param statistic A character or NULL. It indicates the statistics printed
#'   in the plot while there are replicates in input data. Available values are:
#'   \itemize{
#'     \item \strong{sem} Standard error of mean;
#'     \item \strong{ci} 95% confidence interval.
#'   }
#'   If it is \code{NULL}, no statistics will be printed.
#'
#' @return A data frame. It contains the concentrations for selected drugs, the
#'   selected values for plotting, and the text for printing on the heatmap.
.Extract2DrugPlotData <- function(data,
                                  plot_block = 1,
                                  drugs = c(1, 2),
                                  plot_value = "response",
                                  statistic = NULL){
  # 1. Check the input data
  # Data structure of 'data'
  if (!is.list(data)) {
    stop("Input data is not in list format!")
  }
  if (!all(c("drug_pairs", "response") %in% names(data))) {
    stop("Input data should contain at least tow elements: 'drug_pairs' and 
         'response'. Please prepare your data with 'ReshapeData' function.")
  }
  # Parameter 'drugs'
  if (length(drugs) != 2) {
    stop("The length of 'drugs' parameter is not 2. Please chosed exactly 2
         drugs for heatmap.")
  }
  # Parameter 'plot_value'
  avail_value <- c("response", "response_origin", "ZIP_ref", "ZIP_fit",
                   "ZIP_synergy", "HSA_ref", "HSA_synergy", "Bliss_ref",
                   "Bliss_synergy", "Loewe_ref", "Loewe_synergy")
  if (!plot_value %in% avail_value) {
    stop("The parameter 'plot_value = ", plot_value, "' is not available.",
         "Avaliable values are '", paste(avail_value, collapse = ", "), "'.")
  }
  
  # Annotation data
  drug_pair <- data$drug_pairs[data$drug_pairs$block_id == plot_block, ] %>% 
    dplyr::select(
      drug1 = paste0("drug", drugs[1]),
      drug2 = paste0("drug", drugs[2]),
      conc_unit1 = paste0("conc_unit", drugs[1]),
      conc_unit2 = paste0("conc_unit", drugs[2]),
      replicate,
      input_type
    )
  
  # Parameter 'statistic'
  if (is.null(statistic)){
    statistic_table <- drug_pair$replicate
  } else {
    avail_statistic <- c("sem", "ci")
    if (!drug_pair$replicate) {
      warning("The selected block ", plot_block,
              " doesn't have the replicate data. Statistics is not available.")
      statistic_table <- FALSE
    } else if(!statistic %in% avail_statistic) {
      warning("The parameter 'statistic = ", statistic, "' is not available.",
              "Avaliable values are ", paste(avail_statistic, sep = ", "), ".")
      statistic_table <- FALSE
    } else {
      statistic_table <- TRUE
    }
  }
  
  # 1. Extract tables for plotting
  
  # Data table
  concs <- grep("conc\\d", colnames(data$response), value = TRUE)
  selected_concs <- paste0("conc", drugs)
  
  if (statistic_table){
    if (startsWith(plot_value, "response")){
      plot_table <- data$response_statistics
    } else {
      if (!"synergy_scores" %in% names(data)){
        stop("The synergy scores are not calculated. Please run function ",
             "'CalculateSynergy' first.")
      }
      plot_table <- data$synergy_scores_statistics
    }
    plot_table <- plot_table %>% 
      dplyr::filter(block_id == plot_block) %>% 
      dplyr::ungroup()
    if (is.null(statistic)) {
      plot_table <- plot_table %>% 
        dplyr::select(
          dplyr::starts_with("conc"), 
          value = !!paste0(plot_value, "_mean")
        ) %>%
        dplyr::mutate(
          text = as.character(.RoundValues(value))
        )
    } else if (statistic == "sem") {
      plot_table <- plot_table %>% 
        dplyr::select(
          dplyr::starts_with("conc"), 
          value = !!paste0(plot_value, "_mean"),
          statistic = !!paste0(plot_value, "_sem")
        ) %>%
        dplyr::mutate(
          text = paste(
            .RoundValues(value), "\n" ,
            "\u00B1",
            .RoundValues(statistic)
          )
        )
    } else if (statistic == "ci") {
      plot_table <- plot_table %>% 
        dplyr::select(
          dplyr::starts_with("conc"), 
          value = !!paste0(plot_value, "_mean"),
          left = !!paste0(plot_value, "_ci_left"),
          right = !!paste0(plot_value, "_ci_right")
        ) %>%
        dplyr::mutate(
          text = paste0(
            .RoundValues(value), "\n",
            "[",
            .RoundValues(left),
            ", ",
            .RoundValues(right),
            "]"
          )
        )
    }
  } else {
    if (startsWith(plot_value, "response")){
      plot_table <- data$response
    } else {
      if (!"synergy_scores" %in% names(data)){
        stop("The synergy scores are not calculated. Please run function ",
             "'CalculateSynergy' first.")
      }
      plot_table <- data$synergy_scores
    }
    plot_table <- plot_table %>% 
      dplyr::filter(block_id == plot_block) %>% 
      dplyr::select(
        dplyr::starts_with("conc"),
        value = !!plot_value
      ) %>%
      dplyr::mutate(
        text = as.character(.RoundValues(value))
      )
  }
  
  # Extract data for selected two drugs from multi-drug combination
  other_concs <- setdiff(concs, selected_concs)
  if (length(other_concs) > 0) {
    conc_zero <- apply(
      dplyr::select(plot_table, dplyr::all_of(concs)), 
      1,
      function(x) {
        sum(x != 0) <= 2
      })
    plot_table <- plot_table[conc_zero, ]
    other_concs_sum <- plot_table %>% 
      dplyr::ungroup() %>% 
      dplyr::select(dplyr::all_of(other_concs)) %>% 
      rowSums()
    plot_table <- plot_table[other_concs_sum == 0, ] %>% 
      dplyr::select(-dplyr::all_of(other_concs))
  }
  
  # Transform conc into factor
  plot_table[, c("conc1", "conc2")] <- lapply(
    plot_table[, c("conc1", "conc2")],
    function(x) {
      factor(.RoundValues(x))
    }
  )
  return(list(plot_table = plot_table, drug_pair = drug_pair))
}

#' Round the Numbers for Plotting
#' 
#' This function will round the input numbers by 2 digits, if the absolute of 
#' number is larger than or equal to 1. It will take 2 significant digits, if
#' the absolute of number is smaller than 1. 
#'
#' @param numbers A vector of numeric values. It contains the numbers need to
#' be rounded.
#'
#' @return A vector of rounded numbers.
.RoundValues <- function(numbers) {
  numbers[abs(numbers) >= 1] <- round(numbers[abs(numbers) >= 1], 2)
  numbers[abs(numbers) < 1] <- signif(numbers[abs(numbers) < 1], 2)
  return(numbers)
}

#' Convert Font Size from pt to mm
#'
#' This function converts font sizes from "pt" unite to "mm" unite.
#'  
#' @param x A numerical value. It is the font size in "pt" unite.
#'
#' @return A numerical value in "mm" unite
.Pt2mm <- function(x) {
  5 * x / 14
}

#' Make a smooth surface for scores
#'
#' @param scores.mat a matrix contains scores which will be visualized
#' @param len length of the interval between plotted data points.
#'
#' @return a matrix which 
#' @useDynLib synergyfinder, .registration=TRUE
.ExtendedScores <-  function (scores.mat, len) {
  # len: how many values need to be predicted between two adjacent elements
  #      of scores.dose
  options(scipen = 999)
  nr <- nrow(scores.mat)
  nc <- ncol(scores.mat)
  
  # missing value imputation
  while (sum(is.na(scores.mat))) {
    scores.mat <- ImputeNA(scores.mat)
  }
  ext.row.len <- (nr - 1) * (len + 2) - (nr - 2)
  ext.col.len <- (nc - 1) * (len + 2) - (nc - 2)
  
  extended.row.idx <- seq(1, nr, length = ext.row.len)
  extended.col.idx <- seq(1, nc, length = ext.col.len)
  
  krig.coord <- cbind(rep(extended.row.idx, each = ext.col.len),
                      rep(extended.col.idx, times = ext.row.len))
  extended.scores <- kriging(data = c(scores.mat),
                             data.coord = cbind(rep(seq_len(nr), nc),
                                                rep(seq_len(nc), each=nr)),
                             krig.coord = krig.coord,
                             cov.mod = "whitmat", grid = FALSE,
                             sill = 1, range = 10,
                             smooth = 0.8)$krig.est
  extended.scores <- matrix(extended.scores, nrow = ext.row.len,
                            ncol = ext.col.len, byrow = TRUE)
  
  # extended.scores = data.frame(extended.scores)
  extended.scores <- round(extended.scores, 3)
  
  row.dose <- as.numeric(rownames(scores.mat))
  col.dose <- as.numeric(colnames(scores.mat))
  
  extend.row.dose <- mapply(function(x, y){seq(from = x, to = y,
                                               length.out = len + 2)},
                            row.dose[-nr], row.dose[-1])
  extend.row.dose <- unique(round(c(extend.row.dose), 8))
  
  extend.col.dose <- mapply(function(x, y){seq(from = x, to = y,
                                               length.out = len + 2)},
                            col.dose[-nc], col.dose[-1])
  extend.col.dose <- unique(round(c(extend.col.dose), 8))
  
  rownames(extended.scores) <- extend.row.dose
  colnames(extended.scores) <- extend.col.dose
  
  return(extended.scores)
}