# TidyComb
# Functions for calculating drug synergy scores.
#
# Functions in this page:
#
# CalculateSensitivity: Calculate the sensitivity scores for drug combinations

#' Calculate the synergy scores for drug combinations
#'
#' \code{CalculateSynergy} is the main function for calculating synergy scores
#' based on model(ZIP, Bliss, Loewe, and HSA) fron one dose-response
#' \strong{matrix}.
#'
#' @param data  a list object generated by function \code{\link{ReshapeData}}.
#' @param method a parameter to specify which models to use to calculate the
#'   synergy scores. Choices are "ZIP", "Bliss", "HSA" and "Loewe". Defaults to
#'   "ZIP".
#' @param adjusted a logical value. If it is \code{TRUE}, the
#'   'adjusted.response.mats' will be used to calculate synergy scores. If it is
#'   \code{FALSE}, the raw data ('dose.response.mats') will be used to calculate
#'   synergy scores.
#' @param iteration a integer. It indicates the number of iterations for synergy
#'   scores calculation on data with replicates.
#' @param seed a integer or NULL. It is used to set the random seed in synergy
#'   scores calculation on data with replicates. 
#'
#' @return a list. It contains 4 elements:
#'   \itemize{
#'     \item \strong{dose.response.mats} The original input dose-response matrix
#'     \item \strong{adjusted.response.mats} The dose response matrix adjusted
#'       by functions: \code{\link{AddNoise}}, \code{\link{ImputeNA}}, and
#'       \code{\link{CorrectBaseLine}}.
#'     \item \strong{drug_pairs} a data frame contains the name of the row drug,
#'     the name of the column drug, concentration unit and block IDs.
#'     \item \strong{scores} It contains the modified response value and 4
#'     type of synergy scores of each drug dose response pair.
#'     \item \strong{method} the method used to calculate the synergy scores.
#'  }
#'
#' @author
#'   \itemize{
#'     \item Liye He \email{liye.he@helsinki.fi}
#'     \item Shuyu Zheng \email{shuyu.zheng@helsinki.fi}
#'  }
#'
#' @export
#' 
#' @author
#' Jing Tang \email{jing.tang@helsinki.fi}
#' Shuyu Zheng \email{shuyu.zheng@helsinki.fi}
#'
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' scores <- CalculateSensitivity(data)
CalculateSensitivity <- function(data, adjusted = TRUE,
                             iteration = 100, seed = 123) {
  options(scipen = 999)
  # 1. Check the input data
  if (!is.list(data)) {
    stop("Input data is not in list format!")
  }
  if (!all(c("drug_pairs", "response") %in% names(data))) {
    stop("Input data should contain at least tow elements: 'drug_pairs' and 
         'response'. Please prepare your data with 'ReshapeData' function.")
  }
  
  # 2. Select the dose response table for plotting.
  if (adjusted) {
    response <- data$response %>%
      dplyr::select(-response_origin)
  } else {
    response <- data$response %>%
      dplyr::select(-response) %>% 
      dplyr::rename(response = response_origin)
  }

  # 3. Calculate RI and CSS
  blocks <- unique(response$block_id)
  scores <- NULL
  scores_statistics <- NULL
  for (b in blocks) {
    response_one_block <- response %>% 
      dplyr::filter(block_id == b) %>% 
      dplyr::select(-block_id) %>% 
      dplyr::ungroup()
    concs <- grep("conc\\d", colnames(response_one_block), value = TRUE)
    
    if (data$drug_pairs$replicate[data$drug_pairs$block_id == b]){
      tmp_iter <- NULL
      set.seed(seed)
      for(i in 1:iteration){
        response_boot <- .Bootstrapping(response_one_block)
        # Calculate RI
        single_drug_data <- ExtractSingleDrug(response_boot)
        ri <- as.data.frame(lapply(single_drug_data, CalculateSens))
        colnames(ri) <- sub("conc", "ri_", colnames(ri))
        
        # Calculate IC50 for all drugs
        ic50 <- lapply(
          single_drug_data,
          function(x) {
            model <- FitDoseResponse(x)
            coe <- FindModelPar(model)
            type <- FindModelType(model)
            CalculateIC50(coe, type, max(x$dose))
          }) %>% 
          as.data.frame()
        colnames(ic50) <- sub("ri", "ic50", colnames(ri))
        
        # Calculate CSS
        css <- CalculateCSS(response_boot, ic50 = ic50)
        
        # Assemble data frame
        tmp <- cbind.data.frame(ic50, ri, css)
        tmp_iter <- rbind.data.frame(tmp_iter, tmp)
      }
      SensMean <- colMeans(tmp_iter)
      tmp <- as.data.frame(as.list(SensMean)) %>%
        dplyr::mutate(block_id = b)
      SensSd <- apply(tmp_iter, 2, sd)
      SensSem <- SensSd / iteration
      SensCI95 <- stats::qt(0.975, df = iteration - 1) * SensSem
      names(SensMean) <- paste0(names(SensMean), "_mean")
      names(SensSd) <- paste0(names(SensSd), "_sd")
      names(SensSem) <- paste0(names(SensSem), "_sem")
      names(SensCI95) <- paste0(names(SensCI95), "_CI95")
      tmp_sensitivity_statistic <- as.data.frame(as.list(c(SensMean,
                                                           SensSd,
                                                           SensSem,
                                                           SensCI95
                                                           ))) %>% 
        dplyr::mutate(block_id = b)
      scores <- rbind.data.frame(scores, tmp)
      scores_statistics <- rbind.data.frame(
        scores_statistics,
        tmp_sensitivity_statistic
      )
    } else{
      # Calculate RI
      single_drug_data <- ExtractSingleDrug(response_one_block)
      ri <- as.data.frame(lapply(single_drug_data, CalculateSens))
      colnames(ri) <- sub("conc", "ri_", colnames(ri))
      
      # Calculate IC50 for all drugs
      ic50 <-lapply(
        single_drug_data,
        function(x) {
          model <- FitDoseResponse(x)
          coe <- FindModelPar(model)
          type <- FindModelType(model)
          CalculateIC50(coe, type, max(x$dose))
        }) %>% 
        as.data.frame()
      colnames(ic50) <- sub("ri", "ic50", colnames(ri))
      
      # Calculate CSS
      css <- CalculateCSS(response_one_block, ic50 = ic50)
      
      # Assemble data frame
      tmp <- cbind.data.frame(ic50, ri, css) %>% 
        dplyr::mutate(block_id = b)
      scores <- rbind.data.frame(scores, tmp)
    }
  }
  ## 4. Save data into the list
  data$drug_pairs <- data$drug_pairs %>% 
    dplyr::left_join(scores, by = "block_id")
  if (length(scores_statistics) != 0){
    data$sensitivity_scores_statistics <- dplyr::select(
      scores_statistics,
      block_id,
      dplyr::everything()
    )
  }
  return(data)
}


CalculateCSS <- function(response, ic50) {
  concs <- grep("conc\\d", colnames(response), value = TRUE)
  # Calculate CSS for all drug pairs
  conc_zero <- apply(
    dplyr::select(response, - response), 
    1,
    function(x) {
      sum(x != 0) <= 2
    })
  response_two_drugs <- response[conc_zero, ]
  
  conc_pairs <- combn(concs, 2)
  
  css <- vector("list", 2 * ncol(conc_pairs))
  names(css) <- apply(
    conc_pairs, 2, 
    function(x){
      c(paste0(sub("conc", "css", x[1]), sub("conc", "_ic50", x[2])),
        paste0(sub("conc", "css", x[2]), sub("conc", "_ic50", x[1])))
    }
  )
  for (i in 1:ncol(conc_pairs)) {
    pair <- conc_pairs[, i]
    css_c <- pair[1]
    ic50_c <- pair[2]
    other_concs <- setdiff(concs, pair)
    if (length(other_concs) > 0) {
      other_concs <- response_two_drugs %>% 
        dplyr::ungroup() %>% 
        dplyr::select(dplyr::all_of(other_concs)) %>% 
        rowSums()
      response_pair <- response_two_drugs[other_concs == 0, ] %>% 
        dplyr::select(dplyr::all_of(pair), response)
    } else {
      response_pair <- response_two_drugs
    }
    for (css_c in pair) {
      ic50_c <- setdiff(pair, css_c)
      tmp_css <- response_pair %>% 
        dplyr::rename(dose = !!ic50_c) %>% 
        dplyr::group_by(!!as.name(css_c)) %>% 
        tidyr::nest(data = dplyr::all_of(c("dose", "response"))) %>% 
        dplyr::mutate(response = furrr::future_map(data, function(x){
          PredictResponse(x, dose = ic50[[sub("conc", "ic50_", ic50_c)]])
        })) %>% 
        dplyr::select(dose = !!as.name(css_c), response) %>% 
        tidyr::unnest(cols = c(response)) %>% 
        CalculateSens()
      css_name <- paste0(
        sub("conc", "css", css_c),
        sub("conc", "_ic50", ic50_c)
      )
      css[[css_name]] <- tmp_css
    }
  }
  css <- as.data.frame(css)
  css$css <- rowMeans(css)
  return(css)
}