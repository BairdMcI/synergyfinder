# SynergyFinder
# Functions for processing drug response matrix.
#
# Functions in this page:
#
# PlotDoseResponse: Visualize the drug combination dose-response data
# PlotDoseResponseMultiDrug: Visualize the multi-drug combination dose-response data

# Combined plots ----------------------------------------------------------


#' Visualize the drug combination dose-response data
#'
#' A function to visualize the drug combination dose-response data
#'
#' @param data a list object generated by function \code{\link{ReshapeData}}.
#' @param adjusted a logical value. If it is \code{FALSE}, original response
#'   matrix will be plotted. If it is \code{TRUE}, adjusted response matrix will
#'   be plotted.
#' @param block_ids A vector characters or NULL. It contains the block IDs for
#'   the blocks user want to visualize. By default, it is NULL so that the
#'   visualization of all the drug combinations in the data is returned.
#' @param color.low.response a charactor in R color format. It indicates the
#' color for the response lower than 0. Default setting is "green".
#' @param color.high.response a charactor in R color format. It indicates the
#' color for the response higher than 0. Default setting is "red".
#' @param color.conc a charactor in R color format. It indicates the
#' color for the concentrations label for axises. Default setting is "red".
#' @param Point_color a charactor in R color format. It indicates the
#' color for the data point in the plot. Default setting is "red".
#' @param save_file a parameter to specify if the visualization results are
#'   saved as pdf files in current working directory or not. If it is FALSE,
#'   the results are returned as a list of the plots. It is FALSE by default.
#' @param file_type a character. It indicates the format of files you want to
#'   save as. Default is "pdf". Available values are "jpeg", "bmp", "png",
#'   "tiff", "pdf", "svg".
#' @param file_name a character vector. It indicates the file names, if
#'   user chose to save the plot to local directory.If it is not defined by
#'   user, a default name will be assigned.
#' @param width a numeric value. It indicates the width of saved file.
#' @param height a numeric value. It indicates the height of saved file.
#' @param ... further graphical parameters from \code{plot} for
#'   plotting the single drug dose-response curve. Use e.g., cex.lab to change
#'   the axis label size and cex.axis to change the tick size of axises.
#' @return NULL. The plot will be saved into a local file if
#'   \code{save.file = TRUE}. If \code{save.file = FALSE}, the plot will be
#'   printed in default graphic device.
#'
#' @author
#'   \itemize{
#'     \item Liye He \email{liye.he@helsinki.fi},
#'     \item Shuyu Zheng \email{shuyu.zheng@helsinki.fi}
#'   }
#' @import ggplot2
#' @export
#'
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' PlotDoseResponse(data)
PlotDoseResponse <- function(data,
                             adjusted = TRUE,
                             block_ids = NULL,
                             drugs = c(1, 2),
                             statistic = NULL,
                             title_color = "#635F5D",
                             subtitle_color = "#635F5D",
                             axis_text_color = "#635F5D",
                             axis_title_color = "#635F5D",
                             high_response_color = "#B2182B",
                             low_response_color = "#2166AC",
                             point_color = "#C20F00",
                             curve_color = "black",
                             save_file = FALSE,
                             file_type = "pdf",
                             file_name = NULL,
                             width = 12,
                             height = 6,
                             ...) {
  # 1. Check the input data
  if (!is.list(data)) {
    stop("Input data is not in list format!")
  }
  if (!all(c("drug_pairs", "response") %in% names(data))) {
    stop("Input data should contain at least tow elements: 'drug_pairs' and 
         'response'. Please prepare your data with 'ReshapeData' function.")
  }
  
  # 2. Select the dose response table for plotting.
  if (adjusted) {
    response <- data$response %>%
      dplyr::select(-response_origin)
  } else {
    response <- data$response %>%
      dplyr::select(-response) %>% 
      dplyr::rename(response = response_origin)
  }

  # 3. Select block
  if (!is.null(block_ids)) {
    no_block_id <- setdiff(block_ids, response$block_id)
    if (length(no_block_id) > 0) {
      stop(
        "Selected block_ids ",
        paste(unique(no_block_id), sep = ", "),
        " are not found in the input data. Please check the input data."
      )
    }
  } else {
    block_ids <- unique(response$block_id)
  }

  plots <- vector(mode = "list", length = length(block_ids))
  names(plots) <- block_ids

  i <- 1
  for (b in block_ids) {
    # generate data.plot list

    # ggplot object for heatmap
    dose_response_plot <- PlotHeatmap2Drug(
      data,
      plot_block = b,
      drugs = drugs,
      plot_value = "response", 
      statistic = NULL,
      title_color = title_color,
      subtitle_color = subtitle_color,
      axis_text_color = axis_text_color,
      axis_title_color = axis_title_color,
      high_response_color = high_response_color,
      low_response_color = low_response_color
    )
      # plot dose response curve

    graphics::plot.new()
    graphics::layout(matrix(c(1, 3, 2, 3), 2, 2, byrow = TRUE))

    for (i in drugs){
      PlotDoseResponseCurve(
        data,
        plot_block = b,
        drug_index = i,
        point_color = "#C20F00",
        curve_color = "black",
        title_color = title_color,
        axis_text_color = axis_text_color,
        axis_title_color = axis_title_color,
        Emin = NA,
        Emax = NA
      )
    }
    # vps <- baseViewports()
    # pushViewport()
    print(dose_response_plot, vp = grid::viewport(
      height = grid::unit(1, "npc"),
      width = grid::unit(0.5, "npc"),
      just = c("left", "top"),
      y = 1, x = 0.5
    ))
    # popViewport()
    merge_plot <- grDevices::recordPlot()

    plots[[b]] <- merge_plot
    if (save_file) {
      if (is.null(file_name)) {
        if (adjusted) {
          file <- paste(
            data$drug_pairs[which(data$drug_pairs$block_id == b), 
                            paste0("drug", drugs)],
            "adjusted_dose_response_block",
            b,
            sep = "_"
          )
        } else {
          file <- paste(
            data$drug_pairs[which(data$drug_pairs$block_id == b), 
                            paste0("drug", drugs)],
            "original_dose_response_block",
            b,
            sep = "_"
          )
        }
      } else {
        file <- file_name[i]
        i <- i + 1
      }

      if (!file_type %in% c("jpeg", "bmp", "png", "tiff", "pdf", "svg")) {
        warning(
          "Can not save plot in ", file_type, " format. Avaliable formats are ",
          "'svg', 'jpeg', 'bmp', 'png', 'tiff', and 'pdf'.")
      } else if (file_type == "pdf") {
        grDevices::pdf(paste(file, file_type, sep = "."),
          width = width, height = height
        )
      } else if (file_type == "svg") {
        grDevices::svg(paste(file, file_type, sep = "."),
          width = width, height = height
        )
      } else {
        do.call(file_type, args = list(
          filename = paste(file, file_type, sep = "."),
          width = width, height = height,
          units = "in", res = 600
        ))
      }
      #
      # grDevices::jpeg(file_name, width = 800, height = 600)
      grDevices::replayPlot(merge_plot)
      grDevices::dev.off()
    } else {
      grDevices::dev.new(noRStudioGD = TRUE)
      grDevices::replayPlot(plots[[b]])
      grDevices::dev.off()
    }
  }
  data$dose_response_plots <- plots
  return(data)
}

# Single plots ------------------------------------------------------------

PlotDoseResponseCurve <- function(data,
                                  plot_block = 1,
                                  drug_index = 1,
                                  adjusted = TRUE,
                                  title_color = "#635F5D",
                                  point_color = "#C20F00",
                                  curve_color = "black",
                                  axis_text_color = "#635F5D",
                                  axis_title_color = "#635F5D",
                                  Emin = NA,
                                  Emax = NA) {
  
  # 1. Check the input data
  # Data structure of 'data'
  if (!is.list(data)) {
    stop("Input data is not in list format!")
  }
  if (!all(c("drug_pairs", "response") %in% names(data))) {
    stop("Input data should contain at least tow elements: 'drug_pairs' and 
         'response'. Please prepare your data with 'ReshapeData' function.")
  }
  # Parameter 'drug'
  concs <- grep("conc\\d", colnames(data$response), value = TRUE)
  if (length(drug_index) != 1) {
    stop("The length of 'drug' parameter is not 1. Please chosed only one
         drug in the block for dose-reponse curve ploting.")
  } else if (!drug_index %in% sub("conc", "", concs)) {
    stop("The input drug_index '", drug_index, "' is not found in input data. ",
         "Available indexes are '", 
         paste(sub("conc", "", concs), collapse = "', '"),
         "'.")
  }
  
  # Annotation data
  drug_anno <- data$drug_pairs[data$drug_pairs$block_id == plot_block, ] %>% 
    dplyr::select(drug = paste0("drug", drug_index),
                  unit = paste0("conc_unit", drug_index))
  
  # Extract single drug dose response
  if (!adjusted) {
    response <- data$response %>% 
      dplyr::select(-respone) %>% 
      dplyr::rename(response = response_origin)
  } else {
    response <- data$response
  }
  single_drug_data <- ExtractSingleDrug(response)
  single_drug_data <- single_drug_data[[paste0("conc", drug_index)]]
  # Fit model for the row drug
  drug_model <- FitDoseResponse(single_drug_data, Emin = Emin, Emax = Emax)
  
  # plot the curve for the drug
  # For all of R's graphical devices, the default text size is 12 points but it
  # can be reset by including a pointsize argument to the function that opens
  #the graphical device. From ?pdf:
  
  suppressWarnings(graphics::par(
    mgp = c(2, 0.5, 0),
    font.main = 2,
    font.axis = 2,
    cex.main = 1 / 12 * 13.5, # 13.5 pt
    col.main = title_color,
    col.axis = axis_text_color,
    col.lab = axis_title_color
  ))
  # Plot dots
  graphics::plot(
    x = drug_model,
    xlab = paste0("Concentration (", drug_anno$unit, ")"),
    ylab = "Inhibition (%)",
    type = "obs",
    font.axis = 2,
    cex.lab = 1 / 12 * 10, # 10 pt
    cex.axis = 1 / 12 * 10, # 10 pt
    col = point_color,
    cex = 1,
    pch = 16
  )
  # Plot curve
  graphics::plot(
    x = drug_model,
    type = "none",
    col = curve_color,
    font.axis = 2,
    cex = 1,
    add = TRUE,
    lwd = 3
  )
  # Plot title
  graphics::title(
    paste(
      "Dose Response Curve for Drug",
      drug_anno$drug,
      "in Block",
      plot_block
    )
  )
  # return(p)
}

Plot2DrugStatic <- function(data,
                            plot_block = 1,
                            drugs = c(1, 2),
                            plot_value = "response",
                            statistic = NULL,
                            plot_type = "heatmap",
                            title_color = "#635F5D",
                            subtitle_color = "#635F5D",
                            axis_text_color = "#635F5D",
                            axis_title_color = "#635F5D",
                            high_response_color = "#B2182B",
                            low_response_color = "#2166AC") {
  # Extract plot data
  plot_data <- .Extract2DrugPlotData(
    data = data,
    plot_block = plot_block,
    drugs = drugs,
    plot_value = plot_value,
    statistic = statistic,
  )
  plot_table <- plot_data$plot_table
  drug_pair <- plot_data$drug_pair
  
  # Generate plot title
  if (plot_value == "response"){
    plot_title <- paste(
      "Dose Response Matrix",
      sep = " "
    )
    
    if ("statistic" %in% colnames(plot_data$plot_table)) {
      plot_subtitle <- paste(
        "% inhibition \u00B1",
        switch(
          statistic,
          "sd" = "standard deviation",
          "sem" = "standard error of mean",
          "CI95" = "95% confidence interval"
        )
      )
    } else {
      plot_subtitle <- "% inhibition"
    }
  } else if (plot_value == "response_origin") {
    plot_title <- paste(
      "Dose Response Matrix",
      sep = " "
    )
    
    if ("statistic" %in% colnames(plot_data$plot_table)) {
      plot_subtitle <- paste(
        "% ",
        data_pair$input_type,
        "\u00B1",
        switch(
          statistic,
          "sd" = "standard deviation",
          "sem" = "standard error of mean",
          "CI95" = "95% confidence interval"
        )
      )
    } else {
      plot_subtitle <- "% inhibition"
    }
  } else {
    plot_title <- switch (sub(".*_", "", plot_value),
      "ref" = sub("_ref", " Reference Additive Effect", plot_value),
      "fit" = sub("_fit", " Fetted Effect", plot_value),
      "synergy" = sub("_synergy", " Synergy Score", plot_value)
    )
    
    if ("statistic" %in% colnames(plot_table)) {
      plot_subtitle <- paste(
        switch (sub(".*_", "", plot_value),
          "ref" = "% inhibition",
          "fit" = "% inhibition",
          "synergy" = "synergy score"
        ),
        "\u00B1",
        switch(
          statistic,
          "sd" = "standard deviation",
          "sem" = "standard error of mean",
          "CI95" = "95% confidence interval"
        )
      )
    } else {
      plot_subtitle <- "% inhibition"
    }
  }

  # plot heatmap for dose-response matrix
  if (plot_type == "heatmap") {
    p <- ggplot2::ggplot(
      data = plot_table,
      aes(x = conc2, y = conc1, fill = value)
    ) +
      ggplot2::geom_tile() +
      ggplot2::geom_text(ggplot2::aes(label = text), size = .Pt2mm(9)) +
      ggplot2::scale_fill_gradient2(
        high= high_response_color,
        mid = "#FFFFFF",
        low = low_response_color,
        midpoint = 0,
        name = "Inhibition (%)"
      ) +
      ggplot2::xlab(paste0(drug_pair$drug2, " (", drug_pair$conc_unit2, ")")) +
      ggplot2::ylab(paste0(drug_pair$drug1, " (", drug_pair$conc_unit1, ")")) +
      # Add the title for heatmap
      ggplot2::ggtitle(
        label = paste0(
          "Block ",
          plot_block,
          ": ",
          plot_title
        ),
        subtitle = plot_subtitle
      ) +
      ggplot2::theme(
        plot.title = ggplot2::element_text(
          color = title_color,
          size = 13.5,
          face = "bold",
          hjust = 0.5
        ),
        plot.subtitle = ggplot2::element_text(
          color = subtitle_color,
          size = 12,
          hjust = 0.5
        ),
        panel.background = ggplot2::element_blank(),
        # Set label's style of heatmap
        axis.text = ggplot2::element_text(
          color = axis_text_color,
          face = "bold",
          size = 10
        ),
        axis.title = ggplot2::element_text(
          color = axis_title_color,
          size = 10
        )
      )
  } else if (plot_type == "surface") {
    conc1 <- unique(plot_table$conc1)
    conc2 <- unique(plot_table$conc2)
    summary_score <- round(mean(plot_table$value, na.rm = TRUE), 3)
    # kriging with kriging from SpatialExtremes package!
    mat <- reshape2::acast(plot_table, conc1~conc2, value.var = "value")
    # len: how many values need to be predicted between two concentrations
    len <- 3
    extended_mat <- .ExtendedScores(mat, len)
    colnames(extended_mat) <- seq(1, ncol(extended_mat))
    rownames(extended_mat) <- seq(1, nrow(extended_mat))
    # Color palette
    if (!endsWith("synergy", plot_value)){
      color_range <- range(plot_table$value)
      start_point <- min(plot_table$value) - 5
      end_point <- max(plot_table$value) + 5
      color_level <- round(seq(start_point, end_point, by = 2), 0)
      col1 <- grDevices::colorRampPalette(c(
        "#FFFFFF",
        low_response_color
      ))(length(which(color_level < 0)))
      col2 <- grDevices::colorRampPalette(c(
        "#FFFFFF",
        high_response_color
      ))(length(which(color_level >= 0)))
      col <- c(rev(col1), col2[-1])
    } else {
      color_range <- round(max(abs(plot_table$value)) + 5, 2)
      start_point <- -color_range
      end_point <- color_range
      color_level <- round(seq(start_point, end_point, by = 2), 0)
      col1 <- grDevices::colorRampPalette(c(
        "#FFFFFF",
        low_response_color
      ))(length(which(color_level <= 0)))
      col2 <- grDevices::colorRampPalette(c(
        "#FFFFFF",
        high_response_color
      ))(length(which(color_level >= 0)))
      col <- c(rev(col1), col2[-1])
    }
    
    # x-axis ticks setting
    xaxis <- list(
      at = seq(1, nrow(extended_mat), by = len + 1),
      labels = as.character(sort(conc1))
    )
    
    # y-axis ticks settings
    yaxis <- list(
      at = seq(1, ncol(extended_mat), by = len + 1),
      labels = as.character(sort(conc2))
    )
    
    par1 <- list(
      arrows = FALSE, distance = c(0.8, 0.8, 0.8), col = 1,
      z = list(tick.number = 6),
      x = xaxis, y = yaxis
    )
    zlabs <- list(expression("Synergy score"),
                  rot = 90, axis.key.padding = 0
    )
    xpar <- list(
      paste0(drug_pair$drug1, " (", drug_pair$conc_unit1, ")"),
      # cex = axis.title.cex,
      rot = 20)
    ypar <- list(
      paste0(drug_pair$drug2, " (", drug_pair$conc_unit2, ")"),
      # cex = axis.title.cex,
      rot = -50)
    p <- lattice::wireframe(extended_mat,
                              scales = par1, drape = TRUE,
                              colorkey = list(
                                space = "top", width = 0.5#,
                                #labels = list(cex = legend.lab.cex)
                              ),
                              screen = list(z = 30, x = -55),
                              zlab = zlabs, xlab = xpar, ylab = ypar,
                              zlim = c(start_point, end_point),
                              col.regions = col,
                              main = list(label = plot_title),
                              # cex = main.title.cex),
                              at = lattice::do.breaks(
                                c(start_point, end_point),
                                length(col)
                              ),
                              par.settings = list(
                                axis.line = list(col = "transparent")
                              ),
                              zoom = 1, aspect = 1
    )
    print(p)
    p <- grDevices::recordPlot()
  }
  return(p)
}

PlotMultiDrugBar <- function(data,
                             plot_block = 1,
                             plot_value = "response",
                             sort_by = "conc1",
                             highlight_row = NULL,
                             bar_color = "grey50",
                             highlight_color = "#B2182B") {
  plot_data <- .ExtractMultiDrugPlotData(
    data,
    plot_block = plot_block,
    plot_value = plot_value
  )
  
  drug_pair <- plot_data$drug_pair
  
  plot_table <- plot_data$plot_table %>% 
    dplyr::arrange(!!as.name(sort_by))
  concs <- grep("conc", colnames(plot_table), value = TRUE)
  cname <- NULL
  for (i in 1:ncol(plot_table)) {
    test_name <- colnames(plot_table)[i]
    if (startsWith(test_name, "conc")){
      cname[i] <- paste0(
        drug_pair[[sub("conc", "drug", test_name)]],
        "\n(",
        drug_pair[[sub("conc", "conc_unit", test_name)]],
        ")"
      )
    } else {
      cname[i] <- switch (
        sub(".*_", "", test_name),
        "ref" = sub("_ref", " Reference Additive Effect\n(% inhibition)", test_name),
        "fit" = sub("_fit", " Fetted Effect\n(% inhibition)", test_name),
        "synergy" = sub("_synergy", " Synergy Score", test_name),
        "origin" = paste0("Input Response\n(% ", drug_pair$input_type, ")"),
        "Response\n(% inhibition)"
      )
    }
  }
  plot_table <- plot_table %>% 
    dplyr::mutate(id = seq(1, dplyr::n())) 
  plot_table_reshape <- plot_table 
  colnames(plot_table_reshape) <- c(cname, "id")
  plot_table_reshape <- plot_table_reshape %>% 
    tidyr::gather(key = "metric", value = "value", -id)
  plot_table_reshape$metric <- factor(
    plot_table_reshape$metric,
    levels = cname
    )
  p <- ggplot2::ggplot() +
    ggplot2::geom_bar(
      data = plot_table_reshape,
      aes(x = id, y = value),
      fill = bar_color,
      stat = "identity"
    ) +
    ggplot2::scale_x_continuous(expand = c(0, 0)) +
    ggplot2::scale_y_continuous(expand = c(0.2, 0)) +
    ggplot2::theme(
      axis.title = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      strip.background =element_rect(fill="#E5E2E0"),
      panel.background = element_rect(fill = "#F5F3F2"),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      legend.position = "none") + coord_flip() +
    ggplot2::facet_grid(cols = vars(metric), rows = NULL, scales = "free")
  
  # Highlight data row
  concs <- sort(concs)
  if (!is.null(highlight_row)) {
    if (length(highlight_row) != length(concs)) {
      stop("The length of input 'highlight_row' is not equal to the number of ",
           "drugs in data. Please give ", length(concs),
           " concentrations to specify the highlighted row.")
    }
    plot_table <- plot_table %>% 
      dplyr::relocate(dplyr::any_of(concs))
    conc_exist <- NULL
    for (i in 1:length(concs)) {
      conc_exist[i] <- highlight_row[i] %in%
        plot_table[paste0("conc", i)][[1]]
    }
    if (!all(conc_exist)) {
      stop("The concentration for drug", paste(which(!conc_exist)), 
      "specified by 'highlight_row' is not in data.")
    }
    selected_id <- unique(
      plot_table$id[
        apply(
          plot_table[, concs],
          1,
          function(x) {
            all(x == highlight_row)
          }
        )
      ]
    )
    selected_data <- plot_table_reshape[plot_table_reshape$id %in% selected_id, ]
    p <- p +
      .HighlightBarPlot(selected_data, highlight_color = highlight_color)
  }
  return(p)
}
PlotMultiDrugSurface <- function(data,
                                 plot_block = 1,
                                 drugs = c(1, 2),
                                 plot_value = "response",
                                 statistic = NULL,
                                 title_color = "#635F5D",
                                 subtitle_color = "#635F5D",
                                 axis_text_color = "#635F5D",
                                 axis_title_color = "#635F5D",
                                 high_response_color = "#B2182B",
                                 low_response_color = "#2166AC") {
  plot_data <- .ExtractMultiDrugPlotData(
    data,
    plot_block = plot_block,
    plot_value = plot_value,
    statistic = statistic
  )
  
  drug_pair <- plot_data$drug_pair
  
  plot_table <- plot_data$plot_table
  # Generate plot title
  if (plot_value == "response"){
    plot_title <- paste(
      "Dose Response Matrix",
      sep = " "
    )
    if ("statistic" %in% colnames(plot_table)) {
      plot_subtitle <- paste(
        "% inhibition \u00B1",
        switch(
          statistic,
          "sd" = "standard deviation",
          "sem" = "standard error of mean",
          "CI95" = "95% confidence interval"
        )
      )
    } else {
      plot_subtitle <- "% inhibition"
    }
  } else if (plot_value == "response_origin") {
    plot_title <- paste(
      "Dose Response Matrix",
      sep = " "
    )
    if ("statistic" %in% colnames(plot_table)) {
      plot_subtitle <- paste(
        "% ",
        data_pair$input_type,
        "\u00B1",
        switch(
          statistic,
          "sd" = "standard deviation",
          "sem" = "standard error of mean",
          "CI95" = "95% confidence interval"
        )
      )
    } else {
      plot_subtitle <- "% inhibition"
    }
  } else {
    plot_title <- switch (sub(".*_", "", plot_value),
                          "ref" = sub("_ref", " Reference Additive Effect", plot_value),
                          "fit" = sub("_fit", " Fetted Effect", plot_value),
                          "synergy" = sub("_synergy", " Synergy Score", plot_value)
    )
    
    if ("statistic" %in% colnames(plot_table)) {
      plot_subtitle <- paste(
        switch (sub(".*_", "", plot_value),
                "ref" = "% inhibition",
                "fit" = "% inhibition",
                "synergy" = "synergy score"
        ),
        "\u00B1",
        switch(
          statistic,
          "sd" = "standard deviation",
          "sem" = "standard error of mean",
          "CI95" = "95% confidence interval"
        )
      )
    } else {
      plot_subtitle <- "% inhibition"
    }
  }

  # ------------------------
  # Dimension reduction
  # ------------------------
  # Each row in the result table can be considered as a feature
  # We need to project these features into a square matrix for example, 216 rows into 15x15 matrix
  # How to adjust the locations of the features in a bounded domain with the constraints that each pixel contain at most one feature?
  ndrugs <- length(concs)
  # https://stackoverflow.com/questions/44503255/rank-vector-with-some-equal-values
  data <- apply(plot_table[,c(1:ndrugs)], 2, function(x) as.integer(factor(x))) # determine the order of the concs for each drug, lower order smaller conc
  rownames(data) <- plot_table$response
  distance <- vegan::vegdist(data, method = "euclidean")
  mds_coor <- cmdscale(distance)
  mds_data <- data.frame(
    x = mds_coor[, 1],
    y = mds_coor[, 2],
    value = as.numeric(rownames(mds_coor)),
    stringsAsFactors = FALSE)
  # Interpolate values to generate a matrix while
  extended_x <- seq(min(mds.coor[, 1]), max(mds.coor[, 1]), by = 0.1)
  extended_y <- seq(min(mds.coor[, 2]), max(mds.coor[, 2]), by = 0.1)
  kriging_coor <- cbind(
    rep(extended_x, each = length(extended_y)),
    rep(extended_y, times = length(extended_x))
  )
  extended_mat <- kriging(
    data = mds_data$value,
    data.coord = cbind(mds_data[, "x"], mds_data[, "y"]),
    krig.coord = kriging_coor,
    cov.mod = "whitmat", grid = FALSE,
    sill = 1, range = 10,
    smooth = 0.8
  )$krig.est
  extended_mat <- matrix(extended_mat,
                         nrow = length(extended_x),
                         ncol = length(extended_y), byrow = TRUE
  )
  x <- extended_x
  y <- extended_y
  
  plotly::plot_ly() %>% 
    plotly::add_surface(x = ~x, y = ~y, z = extended_mat) %>% 
    plotly::add_trace(x = mds_data$y, y = mds_data$x, z = mds_data$value, mode = "markers", type = "scatter3d", 
                  marker = list(size = 5, color = "red", symbol = 104)) 
  
}

PlotBarameter <- function(data,
                          plot_block = 1,
                          plot_concs,
                          weight = 500,
                          high = 500,
                          start_angle = - pi * 1 / 4,
                          end_angle = pi * 5 / 4,
                          graduation_color = "#6C6C6C",
                          needle_color = "#6C6C6C",
                          needle_text_size = 5,
                          needle_text_offset = 50,
                          graduation_label_size = 4,
                          graduation_label_offset = 0.7,
                          annotation_label_size = 4,
                          annotation_label_offset = 0.6,
                          annotation_label_color = "#6C6C6C",
                          font_family = "",
                          color_bar_color = "#8f1b01",
                          color_bar_outer = 9,
                          color_bar_inner = 8,
                          major_graduation_outer = 7.8,
                          minor_graduation_inner = 7.5,
                          major_graduation_inner = 7) {
  
  # Prepare data tables for plot
  drug_pair <- data$drug_pairs[which(data$drug_pairs$block_id == plot_block), ]
  concs <- grep("conc", colnames(data$response), value = TRUE)
  concs <- sort(concs)
  if (drug_pair$replicate) {
    plot_table <- data$response_statistics %>% 
      dplyr::filter(block_id == plot_block) %>% 
      dplyr::select(block_id, dplyr::all_of(concs), response = response_mean)
  } else {
    plot_table <- data$response %>% 
      dplyr::filter(block_id == plot_block) %>% 
      dplyr::select(block_id, dplyr::all_of(concs), response)
  }
  if ("synergy_scores" %in% names(data)) {
    plot_table <- plot_table %>% 
      dplyr::left_join(
        dplyr::filter(data$synergy_scores, block_id == plot_block),
        by = c("block_id", concs)
      ) %>% 
      dplyr::ungroup() %>% 
      dplyr::select(-block_id) %>% 
      dplyr::relocate(dplyr::any_of(concs))
  } else {
    plot_table <- plot_table %>% 
      dplyr::ungroup() %>% 
      dplyr::select(-block_id) %>% 
      dplyr::relocate(dplyr::any_of(concs))
  }
  
  # Check input "plot_concs"
  if (length(plot_concs) != length(concs)) {
    stop("The length of input 'plot_concs' is not equal to the number of ",
         "drugs in data. Please specify ", length(concs),
         " concentrations in 'plot_concs'.")
  }
  conc_exist <- NULL
  for (i in 1:length(concs)) {
    conc_exist[i] <- plot_concs[i] %in%
      plot_table[paste0("conc", i)][[1]]
  }
  if (!all(conc_exist)) {
    stop("The concentration for drug", paste(which(!conc_exist)), 
         "specified by 'highlight_row' is not in data.")
  }
  selected_data <- plot_table[
    apply(
      plot_table[, concs],
      1,
      function(x) {
        all(x == plot_conc)
      }
    ),
  ]
  
  # Data table for color bar
  angle_slice = (end_angle - start_angle)/100
  
  color_bar_data <- data.frame(
    start = seq(start_angle, end_angle, length.out = 101),
    end = seq(start_angle, end_angle, length.out = 101) + angle_slice,
    label = seq(0, 100, length.out = 101),
    stringsAsFactors = FALSE)
  
  # Data table for needle (The coordinate for vertex of triangle)
  needle_value <- selected_data$response
  theta_radius = angle_slice * needle_value + start_angle;
  needle_length = (color_bar_outer + color_bar_inner) / 2;
  needle <- data.frame(
    theta = c(theta_radius, theta_radius - pi /2, theta_radius + pi /2),
    r = c(needle_length, 0.15, 0.15),
    stringsAsFactors = FALSE
    ) %>% 
    dplyr::mutate(x = r * cos(theta), y = r * sin(theta))
  
  # Data table for reference effects
  ref <- grep(".*_ref", colnames(selected_data), value = TRUE)
  if (length(ref) == 0) {
    reference <- NULL
  } else {
    reference <- selected_data %>% 
      dplyr::select(dplyr::all_of(ref)) %>% 
      tidyr::gather(key = "label", value = "value") %>% 
      dplyr::mutate(
        adjust = 0,
        angle = value * angle_slice + start_angle
      ) %>% 
      dplyr::arrange(value)
    reference$label <- sub("_ref", "", reference$label)
    # Separate overlapped labels
    if (nrow(reference) > 1) {
      for (i in 2:nrow(reference)){
        dif <- abs(reference$value[1:(i-1)] - reference$value[i]) < 
          0.7 * annotation_label_size
        if (any(dif)) {
          if (length(dif) == 1) {
            reference$adjust[i] <- 0.15 * annotation_label_size
          } else {
            reference$adjust[i] <- min(
              setdiff(
                seq(
                  0,
                  max(reference$adjust[1:(i-1)][which(dif)]) +
                    0.15 * annotation_label_size,
                  0.15 * annotation_label_size
                ),
                reference$adjust[1:(i-1)][which(dif)]
              )
            )
          }
        }
      }
    }
  }
  
  p <- ggplot(color_bar_data) +
    ggforce::geom_arc_bar(
      data = color_bar_data[-101,],
      aes(
        x0 = 0,
        y0 = 0,
        r0 = color_bar_inner,
        r = color_bar_outer,
        start = start - pi/2,
        end = end - pi/2,
        fill = 100 - label,
        color = 100 - label
      )
    ) +
    ggplot2::scale_fill_gradient(
      high= "grey90",
      low = color_bar_color
    ) +
    ggplot2::scale_color_gradient(
      high= "grey90",
      low = color_bar_color
    ) +
    # minor graduations
    geom_segment(
      aes(
        x = - major_graduation_outer * cos(start),
        xend = - minor_graduation_inner * cos(start),
        y = major_graduation_outer * sin(start),
        yend = minor_graduation_inner * sin(start)
      ),
      color = graduation_color
    ) + 
    # major graduations
    geom_segment(
      data = subset(color_bar_data, label %% 10 == 0),
      aes(
        x = - major_graduation_outer * cos(start),
        xend = - major_graduation_inner * cos(start),
        y = major_graduation_outer * sin(start),
        yend = major_graduation_inner * sin(start)
      ),
      color = graduation_color
    ) +
    # graduation text
    geom_text(
      data = subset(color_bar_data, label %% 10 == 0),
      family = font_family,
      size = graduation_label_size, color = graduation_color,
      aes(
        x = -(major_graduation_inner - graduation_label_offset) * cos(start),
        y = (major_graduation_inner - graduation_label_offset) * sin(start),
        label = paste0(label, "%")
      )
    ) +
    theme(
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.background = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      legend.position = "none"
    ) +
    coord_fixed() 
  # Add needle
  p <- p + 
    # needle
    geom_polygon(
      data = needle,
      aes(x = -x, y = y),
      fill = needle_color
    ) +
    geom_point(
      aes(x = 0, y = 0),
      colour = needle_color,
      size = 4
    ) + 
    # response text
    geom_text(
      aes(x = 0, y = -2),
      size = needle_text_size,
      family = font_family,
      label = paste0("[ ", .RoundValues(needle_value), "% ]"),
      color = needle_color
    )
  # Mark reference
  if (!is.null(reference)) {
    p <- p + 
      # mark reference
      geom_text(
        data = reference,
        size = annotation_label_size,
        family = font_family,
        color = annotation_label_color,
        aes(
          x = -(color_bar_outer + annotation_label_offset + adjust) * cos(angle),
          y = (color_bar_outer + annotation_label_offset + adjust) * sin(angle),
          label = label, angle = (pi /2 - angle) * 180 / pi
        )
      ) +
      geom_segment(
        data = reference,
        color = "white",
        aes(
          x = -color_bar_inner * cos(value * angle_slice + start_angle),
          xend = -color_bar_outer * cos(value * angle_slice + start_angle),
          y = color_bar_inner * sin(value * angle_slice + start_angle),
          yend = color_bar_outer * sin(value * angle_slice + start_angle)
        )
      )
  }
  return(p)
}
# Auxiliary functions -----------------------------------------------------
.HighlightBarPlot <- function(selected_data, highlight_color = "red"){
  p <- list(
    geom_bar(
      data = selected_data,
      aes(x = id, y = value, fill = highlight_color),
      stat = "identity"
    ),
    geom_text(
      data = selected_data,
      aes(x = id,
          y = -Inf,
          label = .RoundValues(value)
      ),
      size = 2,
      hjust = -0.05
    )
  )
  return(p)
}

.Extract2DrugPlotData <- function(data,
                                  plot_block = NULL,
                                  drugs = c(1, 2),
                                  plot_value = "response",
                                  statistic = NULL){
  # 1. Check the input data
  # Data structure of 'data'
  if (!is.list(data)) {
    stop("Input data is not in list format!")
  }
  if (!all(c("drug_pairs", "response") %in% names(data))) {
    stop("Input data should contain at least tow elements: 'drug_pairs' and 
         'response'. Please prepare your data with 'ReshapeData' function.")
  }
  # Parameter 'drugs'
  if (length(drugs) != 2) {
    stop("The length of 'drugs' parameter is not 2. Please chosed exactly 2
         drugs for heatmap.")
  }
  # Parameter 'plot_value'
  avail_value <- c("response", "response_origin", "ZIP_ref", "ZIP_fit",
                   "ZIP_synergy", "HSA_ref", "HSA_synergy", "Bliss_ref",
                   "Bliss_synergy", "Loewe_ref", "Loewe_synergy")
  if (!plot_value %in% avail_value) {
    stop("The parameter 'plot_value = ", plot_value, "' is not available.",
         "Avaliable values are ", paste(avail_value, sep = ", "), ".")
  }
  
  # Annotation data
  drug_pair <- data$drug_pairs[data$drug_pairs$block_id == plot_block, ] %>% 
    dplyr::select(
      drug1 = paste0("drug", drugs[1]),
      drug2 = paste0("drug", drugs[2]),
      conc_unit1 = paste0("conc_unit", drugs[1]),
      conc_unit2 = paste0("conc_unit", drugs[2]),
      replicate,
      input_type
    )
  
  # Parameter 'statistic'
  if (is.null(statistic)){
    statistic_table <- FALSE
  } else {
    avail_statistic <- c("sd", "sem", "CI95")
    if (!drug_pair$replicate) {
      warning("The selected block ", plot_block,
              " doesn't have the replicate data. Statistics is not available.")
      statistic_table <- FALSE
    } else if(!statistic %in% avail_statistic) {
      warning("The parameter 'statistic = ", statistic, "' is not available.",
              "Avaliable values are ", paste(avail_statistic, sep = ", "), ".")
      statistic_table <- FALSE
    } else {
      statistic_table <- TRUE
    }
  }
  
  # 1. Extract tables for plotting
  
  # Data table
  concs <- grep("conc\\d", colnames(data$response), value = TRUE)
  selected_concs <- paste0("conc", drugs)
  
  if (statistic_table){
    if (startsWith(plot_value, "response")){
      plot_table <- data$response_statistics
    } else {
      if (!"synergy_scores" %in% names(data)){
        stop("The synergy scores are not calculated. Please run function ",
             "'CalculateSynergy' first.")
      }
      plot_table <- data$synergy_scores_statistics
    }
    plot_table <- plot_table %>% 
      dplyr::filter(block_id == plot_block) %>% 
      dplyr::ungroup() %>% 
      dplyr::select(
        dplyr::starts_with("conc"), 
        value = !!paste0(plot_value, "_mean"),
        statistic = !!paste(plot_value, statistic, sep = "_")
      ) %>%
      dplyr::mutate(
        text = paste(
          .RoundValues(value), "\n" ,
          "\u00B1",
          .RoundValues(statistic)
        )
      )
  } else {
    if (startsWith(plot_value, "response")){
        plot_table <- data$response
    } else {
      if (!"synergy_scores" %in% names(data)){
        stop("The synergy scores are not calculated. Please run function ",
             "'CalculateSynergy' first.")
      }
      plot_table <- data$synergy_scores
    }
    plot_table <- plot_table %>% 
      dplyr::filter(block_id == plot_block) %>% 
      dplyr::select(
        dplyr::starts_with("conc"),
        value = !!plot_value
      ) %>%
      dplyr::mutate(
        text = as.character(.RoundValues(value))
      )
  }
  
  # Extract data for selected two drugs from multi-drug combination
  other_concs <- setdiff(concs, selected_concs)
  if (length(other_concs) > 0) {
    conc_zero <- apply(
      dplyr::select(plot_table, dplyr::all_of(concs)), 
      1,
      function(x) {
        sum(x != 0) <= 2
      })
    plot_table <- plot_table[conc_zero, ]
    other_concs_sum <- plot_table %>% 
      dplyr::ungroup() %>% 
      dplyr::select(dplyr::all_of(other_concs)) %>% 
      rowSums()
    plot_table <- plot_table[other_concs_sum == 0, ] %>% 
      dplyr::select(-dplyr::all_of(other_concs))
  }
  
  # Transform conc into factor
  plot_table[, c("conc1", "conc2")] <- lapply(
    plot_table[, c("conc1", "conc2")],
    function(x) {
      factor(.RoundValues(x))
    }
  )
  return(list(plot_table = plot_table, drug_pair = drug_pair))
}

.ExtractMultiDrugPlotData <- function(data,
                                      plot_block = 1,
                                      plot_value = "response",
                                      statistic = NULL) {
  # 1. Check the input data
  # Data structure of 'data'
  if (!is.list(data)) {
    stop("Input data is not in list format!")
  }
  if (!all(c("drug_pairs", "response") %in% names(data))) {
    stop("Input data should contain at least tow elements: 'drug_pairs' and 
         'response'. Please prepare your data with 'ReshapeData' function.")
  }
  
  # Parameter 'plot_value'
  avail_value <- c("response", "response_origin", "ZIP_ref", "ZIP_fit",
                   "ZIP_synergy", "HSA_ref", "HSA_synergy", "Bliss_ref",
                   "Bliss_synergy", "Loewe_ref", "Loewe_synergy")
  if (!all(plot_value %in% avail_value)) {
    stop("The input value for parameter 'plot_value' is not available.",
         "Avaliable values are ", paste(avail_value, sep = ", "), ".")
  }
  
  # Annotation data
  drug_pair <- data$drug_pairs[data$drug_pairs$block_id == plot_block, ]
  
  # Parameter 'statistic'
  if (is.null(statistic)){
    statistic_table <- FALSE
  } else {
    avail_statistic <- c("sd", "sem", "CI95")
    if (!drug_pair$replicate) {
      warning("The selected block ", plot_block,
              " doesn't have the replicate data. Statistics is not available.")
      statistic_table <- FALSE
    } else if(!statistic %in% avail_statistic) {
      warning("The parameter 'statistic = ", statistic, "' is not available.",
              "Avaliable values are ", paste(avail_statistic, sep = ", "), ".")
      statistic_table <- FALSE
    } else {
      statistic_table <- TRUE
    }
  }
  
  # Extract tables for plotting
  
  # Data table
  concs <- grep("conc\\d", colnames(data$response), value = TRUE)
  
  if (statistic_table){
    if (startsWith(plot_value, "response")){
      plot_table <- data$response_statistics
    } else {
      if (!"synergy_scores" %in% names(data)){
        stop("The synergy scores are not calculated. Please run function ",
             "'CalculateSynergy' first.")
      }
      plot_table <- data$response_statistics %>% 
        dplyr::left_join(
          data$synergy_scores_statistics,
          by = c("block_id", concs)
        )
    }
    plot_table <- plot_table %>% 
      dplyr::filter(block_id == plot_block) %>% 
      dplyr::ungroup() %>% 
      dplyr::select(
        dplyr::starts_with("conc"), 
        dplyr::all_of(paste0(plot_value, "_mean")),
        dplyr::all_of(paste(plot_value, statistic, sep = "_"))
      )
    colnames(plot_table) <- sub("_mean", "", colnames(plot_table))
  } else {
    if (all(startsWith(plot_value, "response"))){
      plot_table <- data$response
    } else {
      if (!"synergy_scores" %in% names(data)){
        stop("The synergy scores are not calculated. Please run function ",
             "'CalculateSynergy' first.")
      }
      plot_table <- data$response %>% 
        dplyr::left_join(data$synergy_scores, by = c("block_id", concs))
    }
    plot_table <- plot_table %>% 
      dplyr::filter(block_id == plot_block) %>% 
      dplyr::select(
        dplyr::all_of(concs),
        dplyr::all_of(plot_value)
      )
  }
  return(list(plot_table = plot_table, drug_pair = drug_pair))
}

.RoundValues <- function(numbers) {
  numbers[abs(numbers) >= 1] <- round(numbers[abs(numbers) >= 1], 2)
  numbers[abs(numbers) < 1] <- signif(numbers[abs(numbers) < 1], 4)
  return(numbers)
}

.Pt2mm <- function(x) {
  5 * x / 14
}