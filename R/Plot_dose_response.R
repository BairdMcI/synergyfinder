# SynergyFinder
# Functions for processing drug response matrix.
#
# Functions in this page:
#
# PlotDoseResponse: Visualize the drug combination dose-response data
# PlotDoseResponseMultiDrug: Visualize the multi-drug combination dose-response data

#' Visualize the drug combination dose-response data
#'
#' A function to visualize the drug combination dose-response data
#'
#' @param data a list object generated by function \code{\link{ReshapeData}}.
#' @param adjusted a logical value. If it is \code{FALSE}, original response
#'   matrix will be plotted. If it is \code{TRUE}, adjusted response matrix will
#'   be plotted.
#' @param pair.index a parameter to specify which drug combination if there are
#'   many drug combinations in the data. By default, it is NULL so that the
#'   visualization of all the drug combinations in the data is returned.
#' @param color.low.response a charactor in R color format. It indicates the
#' color for the response lower than 0. Default setting is "green".
#' @param color.high.response a charactor in R color format. It indicates the
#' color for the response higher than 0. Default setting is "red".
#' @param color.conc a charactor in R color format. It indicates the
#' color for the concentrations label for axises. Default setting is "red".
#' @param color.point a charactor in R color format. It indicates the
#' color for the data point in the plot. Default setting is "red".
#' @param save.file a parameter to specify if the visualization results are
#'   saved as pdf files in current working directory or not. If it is FALSE,
#'   the results are returned as a list of the plots. It is FALSE by default.
#' @param file.type a character. It indicates the format of files you want to
#'   save as. Default is "pdf". Available values are "jpeg", "bmp", "png",
#'   "tiff", "pdf", "svg".
#' @param file.name a character vector. It indicates the file names, if
#'   user chose to save the plot to local directory.If it is not defined by
#'   user, a default name will be assigned.
#' @param width a numeric value. It indicates the width of saved file.
#' @param height a numeric value. It indicates the height of saved file.
#' @param ... further graphical parameters from \code{plot} for
#'   plotting the single drug dose-response curve. Use e.g., cex.lab to change
#'   the axis label size and cex.axis to change the tick size of axises.
#' @return NULL. The plot will be saved into a local file if
#'   \code{save.file = TRUE}. If \code{save.file = FALSE}, the plot will be
#'   printed in default graphic device.
#'
#' @author
#'   \itemize{
#'     \item Liye He \email{liye.he@helsinki.fi},
#'     \item Shuyu Zheng \email{shuyu.zheng@helsinki.fi}
#'   }
#' @import ggplot2
#' @export
#'
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' PlotDoseResponse(data)
PlotDoseResponse <- function(data, adjusted = TRUE, pair.index = NULL, metric = NULL,
                             color.low.response = "green", color.point = "red",
                             color.high.response = "red", color.conc = "red",
                             save.file = FALSE, file.type = "pdf", file.name = NULL,
                             width = 12, height = 6, ...) {
  # 1. Check the input data
  if (!is.list(data)) {
    stop("Input data is not in list format!")
  }
  if (!all(c("drug.pairs", "response.df") %in% names(data))) {
    stop("Input data should contain at least tow elements: 'drug.pairs' and 
         'response.df'. Please prepare your data with 'ReshapeData' function.")
  }
  if (adjusted & !("response_adj" %in% c(
    colnames(data$response.df),
    colnames(data$replicate.response)
  ))) {
    stop("'adjusted.response.mats' element is required in input data, when
         argument 'adjusted' is setting as TRUE.")
  }
  # 2. Select the dose response table for plotting.
  if (data$replicate) {
    response.df <- data$replicate.response
  } else {
    response.df <- data$response.df
  }
  if (adjusted) {
    response.df <- response.df %>%
      dplyr::select(-response) %>%
      dplyr::rename(response = response_adj)
  } else {
    response.df <- response.df %>%
      dplyr::select(-response_adj)
  }

  if (!is.null(pair.index)) {
    blocks <- pair.index
  } else {
    blocks <- unique(response.df$block_id)
  }

  plots <- vector(mode = "list", length = length(blocks))
  names(plots) <- blocks

  i <- 1
  for (block in blocks) {
    # generate data.plot list
    response <- response.df[which(response.df$block_id == block), ]
    drug.pairs <- data$drug.pairs[which(data$drug.pairs$block_id == block), ]
    data.plot <- list(
      response = response,
      drug.pairs = drug.pairs
    )

    # ggplot object for heatmap
    dose.response.p <- heatmap2D(data.plot,
      metric = metric,
      color.conc = color.conc,
      color.low.response = color.low.response,
      color.high.response = color.high.response
    )
    graphics::plot.new()
    graphics::layout(matrix(c(1, 3, 2, 3), 2, 2, byrow = TRUE))

    curve1D(data.plot, drug = "drug1")
    curve1D(data.plot, drug = "drug2")
    # vps <- baseViewports()
    # pushViewport()
    print(dose.response.p, vp = grid::viewport(
      height = grid::unit(1, "npc"),
      width = grid::unit(0.6, "npc"),
      just = c("left", "top"),
      y = 1, x = 0.4
    ))
    # popViewport()
    merge.plot <- grDevices::recordPlot()

    plots[[block]] <- merge.plot
    if (save.file) {
      if (is.null(file.name)) {
        if (adjusted) {
          file <- paste(drug.pairs$drug1, drug.pairs$drug2, "adjusted_dose_response_block",
            drug.pairs$block_id,
            sep = "_"
          )
        } else {
          file <- paste(drug.pairs$drug1, drug.pairs$drug2, "original_dose_response_block",
            drug.pairs$block_id,
            sep = "_"
          )
        }
      } else {
        file <- file.name[i]
        i <- i + 1
      }

      if (!file.type %in% c("jpeg", "bmp", "png", "tiff", "pdf", "svg")) {
        warning("Can not save plot in ", file.type, " format. Avaliable formats
                are 'svg', 'jpeg', 'bmp', 'png', 'tiff',and 'pdf'.")
      } else if (file.type == "pdf") {
        grDevices::pdf(paste(file, file.type, sep = "."),
          width = width, height = height
        )
      } else if (file.type == "svg") {
        grDevices::svg(paste(file, file.type, sep = "."),
          width = width, height = height
        )
      } else {
        do.call(file.type, args = list(
          filename = paste(file, file.type, sep = "."),
          width = width, height = height,
          units = "in", res = 600
        ))
      }
      #
      # grDevices::jpeg(file.name, width = 800, height = 600)
      grDevices::replayPlot(merge.plot)
      grDevices::dev.off()
    } else {
      grDevices::dev.new(noRStudioGD = TRUE)
      grDevices::replayPlot(plots[[block]])
      grDevices::dev.off()
    }
  }
  return(NULL)
}

# Single plots ------------------------------------------------------------

heatmap2D <- function(data.plot, metric = NULL, color.conc = "black",
                      color.low.response = "green",
                      color.high.response = "red") {
  drug.pairs <- data.plot$drug.pair
  data.plot <- data.plot$response

  # Transform conc into factor
  data.plot[, c("conc1", "conc2")] <- lapply(
    data.plot[, c("conc1", "conc2")],
    factor
  )
  # Round the response values and their statistics
  values <- grep("(conc1|conc2|block_id)", colnames(data.plot),
    perl = TRUE,
    value = TRUE, invert = TRUE
  )
  data.plot[, values] <-
    sapply(data.plot[, values],
      signif,
      digits = 3
    )

  if (!is.null(metric)) {
    avail_metrics <- values[which(values != "response")]
    if (length(avail_metrics) == 0) {
      warning("The input dataset doesn't contain the statistic metrics for replicates.")
      data.plot <- data.plot %>%
        dplyr::mutate(text = response)
    } else {
      if (metric %in% colnames(data.plot)) {
        data.plot <- data.plot %>%
          dplyr::mutate(text = paste0(response, "\n \u00B1", !!as.name(metric)))
      } else {
        warning(
          "Specified metric '", metric, "' is not available. Available ",
          "metrics are: '", paste(avail_metrics, collapse = "', '"), "'"
        )
        data.plot <- data.plot %>%
          dplyr::mutate(text = response)
      }
    }
  } else {
    data.plot <- data.plot %>%
      dplyr::mutate(text = response)
  }

  plot.title <- paste("Dose-response matrix (inhibition)", "\nBlockID:",
    drug.pairs$block_id,
    sep = " "
  )

  # plot heatmap for dose-response matrix
  axis.x.text <- signif(as.numeric(levels(data.plot$conc2)), 4)
  axis.y.text <- signif(as.numeric(levels(data.plot$conc1)), 4)
  dose.response.p <- ggplot2::ggplot(
    data = data.plot,
    aes(x = conc2, y = conc1, fill = response)
  ) +
    ggplot2::geom_tile() +
    ggplot2::geom_text(ggplot2::aes(label = text)) +
    ggplot2::scale_fill_gradient2(
      low = color.low.response,
      high = color.high.response,
      midpoint = 0, name = "Inhibition (%)"
    ) +
    ggplot2::scale_x_discrete(labels = axis.x.text) +
    ggplot2::scale_y_discrete(labels = axis.y.text) +
    ggplot2::xlab(paste0(drug.pairs$drug2, " (", drug.pairs$conc_unit2, ")")) +
    ggplot2::ylab(paste0(drug.pairs$drug1, " (", drug.pairs$conc_unit1, ")"))

  # Add the title for heatmap
  dose.response.p <- dose.response.p +
    ggplot2::ggtitle(plot.title) +
    ggplot2::theme(plot.title = ggplot2::element_text(size = 15))

  # Set label's style of heatmap
  dose.response.p <- dose.response.p +
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(
        color = color.conc,
        face = "bold",
        size = 15
      ),
      axis.text.y = ggplot2::element_text(
        color = color.conc,
        face = "bold",
        size = 15
      ),
      axis.title = ggplot2::element_text(size = 15)
    )
  return(dose.response.p)
}

curve1D <- function(data.plot, drug = "drug1", color.point = "red") {
  drug.pairs <- data.plot$drug.pairs
  data.plot <- data.plot$response

  # Check drug parameter and extract single cell
  columns <- mapUnitConcDrug(drug.pairs = drug.pairs, input.drug = drug)
  conc_unit <- drug.pairs[columns["unit"]]
  # Extract single drug dose response df
  drug.response <- ExtractSingleDrugDf(data.plot,
    conc.name = columns["conc"]
  )

  # Fit model for the row drug
  drug.model <- FitDoseResponse(drug.response) # , ...)

  # plot the curve for the drug
  # dev.control('inhibit')
  # graphics::plot.new()
  suppressWarnings(graphics::par(mgp = c(3, .5, 0)))
  x.lab <- paste0("Concentration (", drug.pairs[columns["unit"]], ")")
  graphics::plot(drug.model,
    xlab = x.lab, ylab = "Inhibition (%)",
    type = "obs", col = color.point, cex = 1.5, pch = 16
  ) # , ...)
  graphics::plot(drug.model,
    xlab = x.lab, ylab = "Inhibition (%)",
    type = "none", cex = 1.5, add = TRUE, lwd = 3
  )
  graphics::title(paste(
    "Dose-response curve for drug:",
    drug.pairs[columns["drug"]], "in Block",
    drug.pairs$block_id
  ), cex.main = 1)
  # p <- grDevices::recordPlot()
  # return(p)
}




# Auxiliary functions -----------------------------------------------------

mapUnitConcDrug <- function(drug.pairs, input.drug) {
  colname.avail <- grep("drug+", colnames(drug.pairs), value = TRUE)
  drug.avail <- drug.pairs[1, colname.avail]
  if (input.drug %in% colname.avail) {
    drug.colname <- input.drug
  } else {
    if (input.drug %in% drug.avail) {
      drug.colname <- colnames(drug.avail)[which(drug.avail[1, ] == input.drug)]
    } else {
      stop(
        "The specified drug '", input.drug, "' is not in the input dataset. The ",
        "available values are either columne names ('",
        paste(colname.avail, collapse = "', '"), "') or the drug names ('",
        paste(drug.avail, collapse = "', '"),
        "') in the data.plot$drug.pairs table"
      )
    }
  }
  conc.colname <- gsub("drug", "conc", drug.colname)
  unit.colname <- gsub("drug", "conc_unit", drug.colname)
  columns <- c(drug.colname, unit.colname, conc.colname)
  names(columns) <- c("drug", "unit", "conc")
  return(columns)
}
